<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RMV Appointment Monitor & Auto-Booker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .card-header h2 {
            color: #333;
            font-size: 1.5rem;
        }

        .section-number {
            display: inline-block;
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 10px;
        }

        .section-instructions {
            background: #f8fafc;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }

        .section-instructions .main-instruction {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .section-instructions .sub-instruction {
            font-size: 0.9rem;
            color: #6b7280;
            line-height: 1.4;
        }

        .status-badge {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: #10b981;
            color: white;
        }

        .status-inactive {
            background: #ef4444;
            color: white;
        }

        .status-pending {
            background: #f59e0b;
            color: white;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
            margin-left: 10px;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .controls-container {
            display: flex;
            gap: 20px;
            margin: 20px 0 15px 0;
        }

        .regional-container {
            flex: 1;
            padding: 15px 0;
        }

        .sort-container {
            width: 280px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .control-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-align: left;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .sort-filter-buttons {
            display: flex;
            gap: 8px;
        }

        .btn-sort {
            padding: 6px 12px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            color: #6b7280;
        }

        .btn-sort:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .btn-sort.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .btn-sort:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f3f4f6;
            color: #9ca3af;
        }

        .distance-badge {
            font-size: 0.75rem;
            color: #6b7280;
            font-weight: 500;
            margin-top: 2px;
        }

        .regional-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn-region {
            padding: 8px 16px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-region:hover {
            border-color: #667eea;
            background: #f9fafb;
        }

        .btn-region.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .btn-region.btn-clear {
            border-color: #ef4444;
            color: #ef4444;
        }

        .btn-region.btn-clear:hover {
            background: #ef4444;
            color: white;
        }

        .service-centers {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .service-center {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            position: relative;
        }

        .service-center:hover {
            border-color: #667eea;
            background: #f9fafb;
        }

        .service-center.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .distance-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #10b981;
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .date-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .date-input {
            width: 100%;
            padding: 10px 40px 10px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
        }

        .date-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .date-input::-webkit-calendar-picker-indicator {
            opacity: 0;
            position: absolute;
            right: 10px;
            cursor: pointer;
            width: 25px;
            height: 25px;
        }

        .date-icon {
            position: absolute;
            right: 12px;
            pointer-events: none;
            font-size: 1.2rem;
        }

        .time-range-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .time-slider-group {
            display: flex;
            flex-direction: column;
        }

        .time-slider-group label {
            margin-bottom: 10px;
            font-weight: 500;
            color: #555;
        }

        .time-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            cursor: pointer;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .time-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .time-display {
            text-align: center;
            margin-top: 10px;
            font-weight: 600;
            color: #667eea;
            font-size: 1.1rem;
        }

        .notifications-inline-container {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin: 20px 0 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }

        .notification-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex: 1;
        }

        .notification-item-header {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .notification-active-info {
            text-align: left;
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 8px;
            padding: 4px 0;
            height: 32px; /* Reserve consistent space */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .notification-active-info.show {
            opacity: 1;
            visibility: visible;
        }

        .notification-active-info#pushInfo {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            height: 32px; /* Match other active states */
        }

        .webhook-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.85rem;
            max-width: 300px;
        }

        /* Appointments Display */
        .appointments-loading {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }

        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .appointments-by-date {
            margin-top: 20px;
        }
        
        .date-section {
            margin-bottom: 30px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            background: white;
        }
        
        .date-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .date-label {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1f2937;
        }
        
        .date-counts {
            font-size: 0.9rem;
            color: #6b7280;
            font-weight: 500;
        }
        
        .date-section-content {
            padding: 20px;
        }
        
        .preferred-group, .other-group {
            margin-bottom: 25px;
        }
        
        .preferred-group:last-child, .other-group:last-child {
            margin-bottom: 0;
        }
        
        .group-header {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .group-header.collapsible {
            cursor: pointer;
            user-select: none;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 6px;
            background: #f9fafb;
            transition: background-color 0.15s ease;
        }
        
        .group-header.collapsible:hover {
            background: #f3f4f6;
        }
        
        .toggle {
            font-size: 0.8rem;
            color: #6b7280;
        }

        .appointments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin-top: 10px;
        }

        /* All appointment grids use consistent column structure */
        /* Mobile: 2 columns for both preferred and other sections */
        @media (max-width: 768px) {
            .appointments-grid {
                grid-template-columns: repeat(2, 1fr);
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            }
            .preferred-group .appointments-grid,
            .other-group .appointments-grid:not(.collapsed) {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Tablet: 3 columns for both preferred and other sections */
        @media (min-width: 769px) and (max-width: 1024px) {
            .appointments-grid {
                grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            }
            .preferred-group .appointments-grid,
            .other-group .appointments-grid:not(.collapsed) {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        /* Desktop: 4 columns for both preferred and other sections */
        @media (min-width: 1025px) {
            .appointments-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            }
            .preferred-group .appointments-grid,
            .other-group .appointments-grid:not(.collapsed) {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        .appointments-grid.collapsed {
            display: none;
        }

        .appointment-card {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            background: white;
            transition: all 0.2s ease;
        }

        .appointment-card.clickable {
            cursor: pointer;
        }

        .appointment-card.clickable:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: #3b82f6;
        }

        .appointment-card:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .appointment-card.preferred {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .appointment-card.preferred::before {
            content: "✨ Matches Your Preferences";
            display: block;
            color: #059669;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .appointment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .appointment-location {
            font-weight: 600;
            color: #374151;
            font-size: 1rem;
        }
        
        .distance-priority {
            font-size: 0.75rem;
            color: #059669;
            background: #d1fae5;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        .appointment-time {
            color: #6b7280;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .appointment-datetime {
            color: #6b7280;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .appointment-link {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.85rem;
            transition: background 0.2s ease;
        }

        .appointment-link:hover {
            background: #5a67d8;
            color: white;
        }

        .no-appointments {
            text-align: center;
            padding: 40px 20px;
            color: #6b7280;
        }

        .no-appointments h3 {
            margin-bottom: 10px;
            color: #374151;
        }

        .countdown-timer {
            font-weight: 600;
            color: #667eea;
        }

        .notification-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
            margin-right: 15px;
        }

        .notification-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 22px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #667eea;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        .notification-label {
            font-size: 1rem;
            color: #374151;
            font-weight: 500;
        }


        .booking-section {
            border-top: 2px solid #f0f0f0;
            padding-top: 20px;
            margin-top: 20px;
        }

        .booking-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }

        .auto-book-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }

        .link-expiration-info {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 5px;
            font-style: italic;
        }


        .monitor-log {
            background: #f9fafb;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-left: 3px solid #667eea;
            background: white;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry.success {
            border-left-color: #10b981;
        }

        .log-entry.error {
            border-left-color: #ef4444;
        }

        .log-entry.info {
            border-left-color: #3b82f6;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8rem;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .time-range-container {
                grid-template-columns: 1fr;
            }

            .booking-grid {
                grid-template-columns: 1fr;
            }

            .controls-container {
                flex-direction: column;
                gap: 15px;
            }

            .sort-container {
                width: 100%;
            }

            .regional-buttons {
                justify-content: center;
            }

            .btn-region {
                flex: 1;
                min-width: 120px;
            }

            .notifications-inline-container {
                flex-direction: column;
                gap: 15px;
            }

            .notification-item {
                flex-direction: row;
                justify-content: flex-start;
                align-items: center;
                gap: 10px;
            }

            .webhook-input {
                max-width: 100%;
            }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sections-hidden {
            display: none;
        }

        .section-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Calendar View Styles */
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 10px;
        }

        .calendar-header h3 {
            margin: 0;
            font-size: 1.5rem;
            color: #374151;
            text-align: center;
            flex: 1;
        }

        .calendar-nav {
            font-size: 1.4rem;
            padding: 12px 20px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 44px;
            font-weight: 600;
        }

        .calendar-nav:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .calendar-nav-btn {
            font-size: 1.8rem;
            padding: 12px 18px;
            border: 2px solid #d1d5db;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 50px;
            min-height: 50px;
            font-weight: 700;
            color: #374151;
        }

        .calendar-nav-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .calendar-nav-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            background: #e5e7eb;
            border-radius: 8px;
            padding: 2px;
            margin-bottom: 20px;
        }

        .calendar-day-header {
            background: #f3f4f6;
            padding: 12px;
            text-align: center;
            font-weight: 600;
            color: #6b7280;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .calendar-day {
            background: white;
            min-height: 60px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
        }

        .calendar-day:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .calendar-day.other-month {
            background: #f9fafb;
            color: #9ca3af;
            cursor: default;
        }

        .calendar-day.other-month:hover {
            transform: none;
            box-shadow: none;
        }

        .calendar-day.has-appointments {
            border: 2px solid transparent;
            background: #f8fafc;
        }

        .calendar-day.preferred-appointments {
            background: #dcfce7;
            border-color: #22c55e;
        }



        .calendar-day-number {
            font-weight: 600;
            font-size: 0.875rem;
            color: #374151;
            margin-bottom: 4px;
        }

        .calendar-day.other-month .calendar-day-number {
            color: #9ca3af;
        }

        .appointment-indicators {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin-top: auto;
        }

        .appointment-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #22c55e;
        }

        .appointment-dot.outside-window {
            background: #f97316;
        }

        .appointment-count {
            font-size: 0.7rem;
            font-weight: 600;
            color: #374151;
            margin-top: 2px;
        }

        .calendar-legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
        }
        
        /* View Toggle Buttons */
        .view-toggle-btn {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #6b7280;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .view-toggle-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
        
        .view-toggle-btn.active {
            background: #059669;
            color: white;
            border-color: #059669;
        }
        
        .view-toggle-btn.active:hover {
            background: #047857;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.875rem;
            color: #374151;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid transparent;
        }

        .legend-color.preferred {
            background: #dcfce7;
            border-color: #22c55e;
        }


        .legend-color.no-appointments {
            background: white;
            border-color: #d1d5db;
        }

        /* Mobile responsive calendar */
        @media (max-width: 768px) {
            .calendar-day {
                min-height: 45px;
                padding: 4px;
            }
            
            .calendar-day-number {
                font-size: 0.75rem;
            }
            
            .appointment-count {
                font-size: 0.6rem;
            }
            
            .calendar-legend {
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }
            
            .calendar-header h3 {
                font-size: 1.25rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚗 RMV Appointment Monitor</h1>
            <p>Automated monitoring and booking system for Mass RMV appointments</p>
        </div>

        <!-- Section 1: RMV Account Connection -->
        <div class="card">
            <div class="card-header">
                <h2><span class="section-number">1</span>🔗 Connect Your RMV Account</h2>
                <span class="status-badge status-pending" id="connectionStatus">DISCONNECTED</span>
            </div>

            <div class="section-instructions">
                <div class="main-instruction">Paste your personalized RMV scheduling link you received from MassRMV via email</div>
                <div class="sub-instruction">Your personal information will be automatically extracted from your RMV account. This link contains your unique access token and appointment details.</div>
                <div style="color: #9ca3af; font-size: 0.85rem; margin-top: 10px; font-family: monospace;">
                    Example: https://rmvmassdotappt.cxmflow.com/Appointment/Index/abc123...?AccessToken=xyz789...
                </div>
                <div style="margin-top: 15px; padding: 12px; background: #f0f9ff; border: 1px solid #bfdbfe; border-radius: 8px;">
                    <div style="color: #1e40af; font-size: 0.9rem; font-weight: 500;">
                        📝 Don't have a personalized link yet?
                    </div>
                    <div style="color: #374151; font-size: 0.85rem; margin-top: 5px;">
                        You can request one from the official MassRMV appointment system. 
                        <a href="https://atlas-myrmv.massdot.state.ma.us/myrmv/_/" target="_blank" style="color: #1d4ed8; text-decoration: underline; font-weight: 500;">
                            Click here to schedule your appointment
                        </a> 
                        and receive your personalized link via email.
                    </div>
                </div>
            </div>

            <div class="form-grid" style="grid-template-columns: 1fr 200px; gap: 20px; align-items: start;">
                <div class="form-group">
                    <label for="rmvUrl">RMV Scheduling URL *</label>
                    <input type="url" id="rmvUrl" placeholder="Paste your RMV scheduling link here..." required>
                </div>
                <div class="form-group">
                    <label for="zipCode">ZIP Code *</label>
                    <input type="text" id="zipCode" placeholder="02101" maxlength="5" pattern="[0-9]{5}" required>
                    <div id="cityDisplay" style="font-size: 0.85rem; color: #059669; margin-top: 5px; font-weight: 500; min-height: 20px;">
                        <!-- City name will appear here -->
                    </div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button id="connectRMV" class="btn btn-primary" style="padding: 12px 30px; font-size: 16px;">
                    <span id="connectText">🔗 Connect to RMV Account</span>
                </button>
            </div>

            <!-- Loading state -->
            <div id="extractionLoader" style="display: none; text-align: center; margin-top: 20px; padding: 20px; background: #f8fafc; border-radius: 8px;">
                <div class="spinner" style="display: inline-block; width: 20px; height: 20px; border: 2px solid #e5e7eb; border-top: 2px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;"></div>
                <strong>Connecting to your RMV account...</strong>
                <div style="margin-top: 8px; color: #6b7280;">Extracting your personal information securely...</div>
            </div>

            <!-- Success notification -->
            <div id="extractionSuccess" style="display: none; margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%); border: 1px solid #bbf7d0; border-radius: 8px;">
                <div style="color: #059669; font-weight: 600; margin-bottom: 8px;">✅ Successfully connected to your RMV account!</div>
                <div style="color: #065f46; font-size: 0.9rem;">Your personal information has been extracted and the system is ready to monitor appointments for you.</div>
            </div>
        </div>

        <!-- Section 2: Service Centers -->
        <div class="card sections-hidden" id="section2">
            <div class="card-header">
                <h2><span class="section-number">2</span>📍 Service Center Selection</h2>
            </div>

            <div class="section-instructions">
                <div class="main-instruction">Select which RMV service centers to monitor for available appointments</div>
                <div class="sub-instruction">🎯 <strong>Smart Location Discovery:</strong> When you enter an RMV URL above, we'll automatically discover the exact locations available for your appointment type. Otherwise, choose from our default Massachusetts locations. Use regional buttons for quick selection. <strong>Maximum 8 locations</strong> can be selected to avoid overloading RMV servers.</div>
            </div>

            <div class="controls-container">
                <div class="regional-container">
                    <div class="regional-buttons" id="regionalButtons">
                        <button class="btn-region" onclick="selectRegion('boston')">Boston Metro</button>
                        <button class="btn-region" onclick="selectRegion('worcester')">Central MA</button>
                        <button class="btn-region" onclick="selectRegion('springfield')">Western MA</button>
                        <button class="btn-region" onclick="selectRegion('north')">North Shore</button>
                        <button class="btn-region" onclick="selectRegion('south')">South Shore</button>
                        <button class="btn-region" onclick="selectRegion('islands')">Islands</button>
                        <button class="btn-region btn-clear" onclick="selectRegion('none')">Clear</button>
                    </div>
                    <div class="control-label">Region</div>
                </div>

                <div class="sort-container">
                    <div class="sort-filter-buttons">
                        <button class="btn-sort active" id="sortAlphabetical" onclick="setSortMode('alphabetical')">A to Z</button>
                        <button class="btn-sort" id="sortDistance" onclick="setSortMode('distance')">Distance</button>
                    </div>
                    <div class="control-label">Sort</div>
                </div>
            </div>

            <div class="service-centers" id="serviceCenters">
                <!-- Service centers will be populated here -->
            </div>
        </div>

        <!-- Section 3: Time Preferences -->
        <div class="card sections-hidden" id="section3">
            <div class="card-header">
                <h2><span class="section-number">3</span>🕐 Appointment Time Preferences</h2>
            </div>

            <div class="section-instructions">
                <div class="main-instruction">Set your preferred date range and time window for appointments</div>
                <div class="sub-instruction">Choose your earliest and latest acceptable dates, then use the sliders to set your preferred time range. The system will prioritize appointments within your selected time window.</div>
            </div>

            <div class="form-grid">
                <div class="form-group">
                    <label for="startDate">Earliest Date</label>
                    <div class="date-input-wrapper">
                        <input type="date" id="startDate" class="date-input">
                        <span class="date-icon">📅</span>
                    </div>
                </div>
                <div class="form-group">
                    <label for="endDate">Latest Date</label>
                    <div class="date-input-wrapper">
                        <input type="date" id="endDate" class="date-input">
                        <span class="date-icon">📅</span>
                    </div>
                </div>
            </div>

            <h4 style="margin: 20px 0 10px 0; color: #666;">Preferred Time Range (10-minute intervals):</h4>
            <div class="time-range-container">
                <div class="time-slider-group">
                    <label for="startTimeSlider">Earliest Time (9:00 AM - 4:50 PM)</label>
                    <input type="range" id="startTimeSlider" class="time-slider" min="54" max="101" value="54" step="1">
                    <div class="time-display" id="startTimeDisplay">9:00 AM</div>
                </div>
                <div class="time-slider-group">
                    <label for="endTimeSlider">Latest Time (9:10 AM - 5:00 PM)</label>
                    <input type="range" id="endTimeSlider" class="time-slider" min="55" max="102" value="102" step="1">
                    <div class="time-display" id="endTimeDisplay">5:00 PM</div>
                </div>
            </div>
        </div>

        <!-- Section 4: Notifications -->
        <div class="card sections-hidden" id="section4">
            <div class="card-header">
                <h2><span class="section-number">4</span>🔔 Notification Settings</h2>
            </div>

            <div class="section-instructions">
                <div class="main-instruction">Configure how you want to be notified when appointments are found</div>
                <div class="sub-instruction">Enable your preferred notification methods. Email and SMS will use the contact information from Section 1. Additional notification services may require specific configuration.</div>
            </div>

            <div class="notifications-inline-container">
                <div class="notification-item">
                    <div class="notification-item-header">
                        <label class="notification-toggle">
                            <input type="checkbox" id="emailNotifications">
                            <span class="toggle-slider"></span>
                        </label>
                        <div class="notification-label">Email</div>
                    </div>
                    <div class="notification-active-info" id="emailInfo">
                        <span id="emailDisplay"></span>
                    </div>
                </div>
                <div class="notification-item">
                    <div class="notification-item-header">
                        <label class="notification-toggle">
                            <input type="checkbox" id="smsNotifications">
                            <span class="toggle-slider"></span>
                        </label>
                        <div class="notification-label">SMS</div>
                    </div>
                    <div class="notification-active-info" id="smsInfo">
                        <span id="phoneDisplay"></span>
                    </div>
                </div>
                <div class="notification-item">
                    <div class="notification-item-header">
                        <label class="notification-toggle">
                            <input type="checkbox" id="pushNotifications">
                            <span class="toggle-slider"></span>
                        </label>
                        <div class="notification-label">Browser</div>
                    </div>
                    <div class="notification-active-info" id="pushInfo">
                        <!-- No text for browser -->
                    </div>
                </div>
                <div class="notification-item">
                    <div class="notification-item-header">
                        <label class="notification-toggle">
                            <input type="checkbox" id="webhookNotifications">
                            <span class="toggle-slider"></span>
                        </label>
                        <div class="notification-label">Webhook</div>
                    </div>
                    <div class="notification-active-info" id="webhookInfo">
                        <input type="url" id="webhookUrl" class="webhook-input" placeholder="https://your-webhook-endpoint.com/notify">
                    </div>
                </div>
            </div>


        </div>

        <!-- Section 5: Available Appointments -->
        <div class="card sections-hidden" id="section5">
            <div class="card-header">
                <h2><span class="section-number">5</span>📅 Available Appointments</h2>
                <span class="status-badge status-inactive" id="monitorStatus">INACTIVE</span>
            </div>
            
            <!-- Instructions + Tab Controls in same row -->
            <div class="section-header-controls" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px;">
                <div class="section-instructions" style="flex: 1; margin-right: 20px;">
                    <div class="main-instruction">Monitor appointments and view results in real-time</div>
                    <div class="sub-instruction" id="monitoringSubInstruction">Start monitoring to automatically check for available appointments every 5 minutes.</div>
                </div>
                
                <!-- Tab buttons (initially disabled) -->
                <div class="view-toggle-container" style="display: flex; gap: 5px; align-items: center; opacity: 0.5;" id="viewToggleContainer">
                    <button id="listViewBtn" class="view-toggle-btn" onclick="switchToListView()" title="List View">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </button>
                    <button id="calendarViewBtn" class="view-toggle-btn active" onclick="switchToCalendarView()" title="Calendar View">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Main Content Area -->
            <div class="main-content-area" id="mainContentArea" style="position: relative; min-height: 300px;">
                <!-- Initial State: Start Monitoring Button (absolutely positioned to block tabs) -->
                <div class="start-monitoring-section" id="startMonitoringSection" style="position: absolute; top: 0; left: 0; right: 0; z-index: 10; text-align: center; padding: 60px 40px; background: #f8fafc; border-radius: 8px; border: 2px dashed #d1d5db;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">🚀</div>
                    <h3 style="margin-bottom: 15px; color: #374151;">Ready to Start Monitoring</h3>
                    <p style="margin-bottom: 15px; color: #6b7280;">Click the button below to begin searching for available appointments</p>
                    <p style="margin-bottom: 25px; color: #9ca3af; font-size: 0.9em;">Once appointments are found, you can switch between calendar and list view using the buttons above</p>
                    <button class="btn btn-primary" id="startBtn" onclick="startMonitoring()" style="font-size: 1.1em; padding: 12px 30px;">Start Monitoring</button>
                </div>
                
                <!-- Loading State (hidden initially) -->
                <div class="appointments-loading" id="appointmentsLoading" style="display: none; text-align: center; padding: 60px 40px;">
                    <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                    <h3 style="margin-bottom: 10px; color: #374151;">Searching for Appointments</h3>
                    <p style="color: #6b7280;">Please wait while we check for available appointments...</p>
                </div>

                <!-- List View Content (blocked by overlay initially) -->
                <div id="listViewContent" style="display: none;">
                    <div id="appointmentsContainer">
                        <div class="appointments-inactive" id="appointmentsInactive">
                            <div style="text-align: center; padding: 40px; color: #6b7280;">
                                <div style="font-size: 3rem; margin-bottom: 15px;">⏸️</div>
                                <h3 style="margin-bottom: 10px; color: #374151;">Monitoring Not Started</h3>
                                <p>Click "Start Monitoring" above to begin searching for appointments</p>
                            </div>
                        </div>
                        <div class="appointments-loading" id="appointmentsLoading" style="display: none;">
                            <div class="loading-spinner"></div>
                            <p>Searching for appointments...</p>
                        </div>
                        <div id="appointmentsList" style="display: none;">
                            <!-- Appointments will be populated here by JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Calendar View Content (blocked by overlay initially) -->
                <div id="calendarViewContent" style="display: block;">
                    <!-- Calendar inactive state -->
                    <div id="calendarInactive" class="inactive-state">
                        <div style="text-align: center; padding: 40px; color: #6b7280;">
                            <div style="font-size: 3rem; margin-bottom: 15px;">🗓️</div>
                            <h3 style="margin-bottom: 10px; color: #374151;">Calendar View Available</h3>
                            <p>Start monitoring to see appointment availability on calendar</p>
                        </div>
                    </div>

                    <!-- Calendar loading state -->
                    <div class="appointments-loading" id="calendarLoading" style="display: none;">
                        <div class="loading-spinner"></div>
                        <p>Searching for appointments...</p>
                    </div>

                    <!-- Calendar content -->
                    <div id="calendarView" style="display: none;">
                        <div class="calendar-container">
                            <div class="calendar-header">
                                <button class="calendar-nav-btn" onclick="previousMonth()">‹</button>
                                <h3 id="currentMonthYear" class="calendar-title">Loading...</h3>
                                <button class="calendar-nav-btn" onclick="nextMonth()">›</button>
                            </div>
                            <div class="calendar-legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #dcfce7; border: 1px solid #059669;"></div>
                                    <span>Preferred appointments available</span>
                                </div>
                            </div>
                            <div class="calendar-grid">
                                <div class="calendar-weekday-headers">
                                    <div class="calendar-weekday-header">Sun</div>
                                    <div class="calendar-weekday-header">Mon</div>
                                    <div class="calendar-weekday-header">Tue</div>
                                    <div class="calendar-weekday-header">Wed</div>
                                    <div class="calendar-weekday-header">Thu</div>
                                    <div class="calendar-weekday-header">Fri</div>
                                    <div class="calendar-weekday-header">Sat</div>
                                </div>
                                <div id="calendarDays" class="calendar-days">
                                    <!-- Calendar days will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Stop Monitoring Button (bottom, hidden initially) -->
            <div class="stop-monitoring-section" id="stopMonitoringSection" style="display: none; text-align: center; margin-top: 20px; padding: 15px; background: #fef2f2; border-radius: 8px;">
                <button class="btn btn-danger" onclick="stopMonitoring()" id="stopBtn" style="font-size: 1em; padding: 8px 20px;">Stop Monitoring</button>
            </div>

        </div>
        

        <!-- Section 6: Statistics -->
        <div class="card sections-hidden" id="section6">
            <div class="card-header">
                <h2><span class="section-number">6</span>📊 Live Statistics</h2>
            </div>

            <div class="section-instructions">
                <div class="main-instruction">Real-time monitoring statistics and performance metrics</div>
                <div class="sub-instruction">Track system activity including total checks performed, appointments found, and notifications sent.</div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="checksCount">0</div>
                    <div class="stat-label">Total Checks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="availableCount">0</div>
                    <div class="stat-label">Appointments Found</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="notificationsSent">0</div>
                    <div class="stat-label">Notifications Sent</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="matchingCount">0</div>
                    <div class="stat-label">Matching Preferences</div>
                </div>
            </div>
        </div>

        <!-- Section 7: Activity Log -->
        <div class="card sections-hidden" id="section7">
            <div class="card-header">
                <h2><span class="section-number">7</span>📝 Activity Log</h2>
                <button class="btn btn-secondary" onclick="clearLog()" style="padding: 8px 16px; font-size: 0.9rem;">Clear Log</button>
            </div>

            <div class="section-instructions">
                <div class="main-instruction">Real-time system activity and monitoring updates</div>
                <div class="sub-instruction">View detailed logs of system activity including appointment checks, notifications sent, errors, and successful bookings. Green entries indicate success, red indicates errors, and blue indicates general information.</div>
            </div>

            <div class="monitor-log" id="monitorLog">
                <div class="log-entry info">System ready. Configure settings and click "Start Monitoring" to begin.</div>
            </div>
        </div>
    </div>

    <script>
        // Service Centers Data - Now Dynamic! (alphabetically sorted with actual RMV addresses for distance calculation)
        
        // Store discovered locations from RMV URL
        let discoveredLocations = null;
        let isUsingDynamicLocations = false;
        let originalServiceCenters = [
            { name: 'Attleboro', address: '75 Park Street, Attleboro MA, 02703', lat: 41.9445, lng: -71.2856 },
            { name: 'Braintree', address: '10 Plain Street, Braintree MA, 02184', lat: 42.2057, lng: -70.9995 },
            { name: 'Brockton', address: '490 Forest Avenue, Brockton MA, 02301', lat: 42.0834, lng: -71.0184 },
            { name: 'Danvers', address: '8 Newbury Street, Danvers MA, 01923', lat: 42.5751, lng: -70.9301 },
            { name: 'Easthampton', address: '116 Pleasant St, East Hampton MA, 01027', lat: 42.2667, lng: -72.6687 },
            { name: 'Fall River', address: '1794 North Main Street, Fall River MA, 02720', lat: 41.7015, lng: -71.1550 },
            { name: 'Greenfield', address: '18 Miner Street, Greenfield MA, 01301', lat: 42.5876, lng: -72.6001 },
            { name: 'Haverhill', address: '229C Lincoln Avenue, Haverhill MA, 01830', lat: 42.7762, lng: -71.0773 },
            { name: 'Lawrence', address: '73C Winthrop Avenue, Lawrence MA, 01843', lat: 42.7070, lng: -71.1631 },
            { name: 'Leominster', address: '500 Research Drive, Leominster MA, 01453', lat: 42.5251, lng: -71.7612 },
            { name: 'Lowell', address: '77 Middlesex Street, Lowell MA, 01852', lat: 42.6334, lng: -71.3162 },
            { name: 'Martha\'s Vineyard', address: '11A Street, Martha\'s Vineyard/Edgertown MA, 02539', lat: 41.3890, lng: -70.5138 },
            { name: 'Milford', address: '138 South Main Street, Milford MA, 01757', lat: 42.1598, lng: -71.5201 },
            { name: 'Nantucket', address: '16 Broad Street, Nantucket MA, 02554', lat: 41.2835, lng: -70.0995 },
            { name: 'New Bedford', address: '212 Theodore Rice Blvd, New Bedford MA, 02740', lat: 41.6362, lng: -70.9342 },
            { name: 'North Adams', address: '33 Main Street, North Adams MA, 01247', lat: 42.7001, lng: -73.1087 },
            { name: 'Pittsfield', address: '333 East Street, Pittsfield MA, 01201', lat: 42.4501, lng: -73.2451 },
            { name: 'Plymouth', address: '40 Industrial Park, Plymouth MA, 02360', lat: 41.9584, lng: -70.6673 },
            { name: 'South Yarmouth', address: '1084 Route 28, South Yarmouth, MA 02664', lat: 41.6707, lng: -70.1995 },
            { name: 'Southbridge', address: '6 Larochelle Way, Southbridge MA, 01550', lat: 42.0751, lng: -72.0334 },
            { name: 'Springfield', address: '1250 St. James Avenue, Springfield MA, 01104', lat: 42.1015, lng: -72.5898 },
            { name: 'Taunton', address: '1 Washington Street, Suite 40, Taunton MA, 02780', lat: 41.9001, lng: -71.0897 },
            { name: 'Watertown', address: '550 Arsenal Street, Watertown MA, 02472', lat: 42.3584, lng: -71.1828 },
            { name: 'Wilmington', address: '355 Middlesex Avenue, Wilmington MA, 01887', lat: 42.5584, lng: -71.1737 },
            { name: 'Worcester', address: '50 SW Cutoff, Worcester MA, 16034', lat: 42.2626, lng: -71.8023 }
        ];
        
        // Initialize serviceCenters with original data
        let serviceCenters = [...originalServiceCenters];

        // Dynamic Regional groupings - updated based on current serviceCenters
        let regions = {
            boston: ['Watertown', 'Braintree'],
            worcester: ['Worcester', 'Milford', 'Leominster', 'Southbridge'],
            springfield: ['Springfield', 'Easthampton', 'Pittsfield', 'North Adams', 'Greenfield'],
            north: ['Danvers', 'Lawrence', 'Haverhill', 'Lowell', 'Wilmington'],
            south: ['Brockton', 'Taunton', 'Fall River', 'Attleboro', 'New Bedford', 'Plymouth', 'South Yarmouth'],
            islands: ['Martha\'s Vineyard', 'Nantucket']
        };

        // Function to dynamically map locations to regions based on coordinates
        function updateRegionalMappings() {
            const currentLocationNames = serviceCenters.map(center => center.name || center);
            
            // Reset regions to empty arrays
            Object.keys(regions).forEach(key => {
                regions[key] = [];
            });
            
            // Map each location to appropriate region based on coordinates and name
            currentLocationNames.forEach(locationName => {
                const locationObj = serviceCenters.find(center => 
                    (center.name || center) === locationName
                );
                const coords = locationObj?.lat !== undefined ? locationObj : null;
                
                // Geographic region assignment based on coordinates and city names
                if (coords) {
                    const lat = coords.lat;
                    const lng = coords.lng;
                    
                    // PRIORITY CHECK: Islands (check first before geographic bounds)
                    if (locationName.match(/Martha.*Vineyard|Nantucket/i)) {
                        regions.islands.push(locationName);
                    }
                    // Boston Metro (within ~25 miles of Boston)
                    else if ((lat >= 42.1 && lat <= 42.6 && lng >= -71.3 && lng <= -70.8) ||
                        locationName.match(/Boston|Cambridge|Watertown|Braintree|Quincy|Newton/i)) {
                        regions.boston.push(locationName);
                    }
                    // North Shore (north of Boston, closer to coast)
                    else if ((lat >= 42.4 && lng >= -71.2) ||
                        locationName.match(/Danvers|Lawrence|Haverhill|Lowell|Wilmington|Lynn|Salem|Peabody|Methuen|Everett/i)) {
                        regions.north.push(locationName);
                    }
                    // South Shore (south of Boston, but exclude islands)
                    else if ((lat <= 42.2 && lng >= -71.2 && !locationName.match(/Martha.*Vineyard|Nantucket/i)) ||
                        locationName.match(/Brockton|Taunton|Fall River|Attleboro|New Bedford|Plymouth|South Yarmouth/i)) {
                        regions.south.push(locationName);
                    }
                    // Central MA (Worcester area)
                    else if ((lng >= -72.1 && lng <= -71.4) ||
                        locationName.match(/Worcester|Milford|Leominster|Southbridge|Fitchburg|Framingham/i)) {
                        regions.worcester.push(locationName);
                    }
                    // Western MA (Springfield and west)
                    else if (lng < -72.1 ||
                        locationName.match(/Springfield|Easthampton|Pittsfield|North Adams|Greenfield|Holyoke/i)) {
                        regions.springfield.push(locationName);
                    }
                    // Default to most appropriate region based on coordinates
                    else {
                        if (lat >= 42.4) regions.north.push(locationName);
                        else if (lat <= 42.0) regions.south.push(locationName);
                        else if (lng <= -72.0) regions.springfield.push(locationName);
                        else regions.worcester.push(locationName);
                    }
                } else {
                    // Fallback for locations without coordinates - use name matching
                    if (locationName.match(/Boston|Cambridge|Watertown|Braintree|Quincy|Newton/i)) {
                        regions.boston.push(locationName);
                    } else if (locationName.match(/Danvers|Lawrence|Haverhill|Lowell|Wilmington|Lynn|Salem/i)) {
                        regions.north.push(locationName);
                    } else if (locationName.match(/Brockton|Taunton|Fall River|Attleboro|New Bedford|Plymouth/i)) {
                        regions.south.push(locationName);
                    } else if (locationName.match(/Worcester|Milford|Leominster|Southbridge|Fitchburg/i)) {
                        regions.worcester.push(locationName);
                    } else if (locationName.match(/Springfield|Easthampton|Pittsfield|North Adams|Greenfield/i)) {
                        regions.springfield.push(locationName);
                    } else if (locationName.match(/Martha.*Vineyard|Nantucket/i)) {
                        regions.islands.push(locationName);
                    } else {
                        // Default assignment to Central MA for unknown locations
                        regions.worcester.push(locationName);
                    }
                }
            });
            
            // Log the updated regional mappings
            addLog(`🗺️ Updated regional mappings: ${Object.entries(regions).map(([region, locations]) => 
                `${region}(${locations.length})`).join(', ')}`, 'info');
        }

        // ZIP code to coordinates mapping (expanded Massachusetts coverage)
        const zipCoords = {
            // Boston Area
            '02101': { lat: 42.3601, lng: -71.0589, city: 'Boston' },
            '02109': { lat: 42.3651, lng: -71.0536, city: 'Boston' },
            '02134': { lat: 42.3584, lng: -71.1311, city: 'Allston' },
            '02138': { lat: 42.3736, lng: -71.1097, city: 'Cambridge' },
            '02184': { lat: 42.2057, lng: -70.9995, city: 'Braintree' },
            '02472': { lat: 42.3584, lng: -71.1828, city: 'Watertown' },
            // North Shore
            '01923': { lat: 42.5751, lng: -70.9301, city: 'Danvers' },
            '01843': { lat: 42.7070, lng: -71.1631, city: 'Lawrence' },
            '01830': { lat: 42.7762, lng: -71.0773, city: 'Haverhill' },
            '01852': { lat: 42.6334, lng: -71.3162, city: 'Lowell' },
            '01887': { lat: 42.5584, lng: -71.1737, city: 'Wilmington' },
            // Central MA
            '01605': { lat: 42.2626, lng: -71.8023, city: 'Worcester' },
            '01757': { lat: 42.1598, lng: -71.5201, city: 'Milford' },
            '01453': { lat: 42.5251, lng: -71.7612, city: 'Leominster' },
            '01550': { lat: 42.0751, lng: -72.0334, city: 'Southbridge' },
            // Western MA
            '01104': { lat: 42.1015, lng: -72.5898, city: 'Springfield' },
            '01027': { lat: 42.2667, lng: -72.6687, city: 'Easthampton' },
            '01201': { lat: 42.4501, lng: -73.2451, city: 'Pittsfield' },
            '01247': { lat: 42.7001, lng: -73.1087, city: 'North Adams' },
            '01301': { lat: 42.5876, lng: -72.6001, city: 'Greenfield' },
            // South Shore
            '02301': { lat: 42.0834, lng: -71.0184, city: 'Brockton' },
            '02780': { lat: 41.9001, lng: -71.0897, city: 'Taunton' },
            '02720': { lat: 41.7015, lng: -71.1550, city: 'Fall River' },
            '02703': { lat: 41.9445, lng: -71.2856, city: 'Attleboro' },
            '02740': { lat: 41.6362, lng: -70.9342, city: 'New Bedford' },
            '02360': { lat: 41.9584, lng: -70.6673, city: 'Plymouth' },
            '02664': { lat: 41.6707, lng: -70.1995, city: 'South Yarmouth' },
            // Islands
            '02539': { lat: 41.3890, lng: -70.5138, city: 'Edgartown' },
            '02554': { lat: 41.2835, lng: -70.0995, city: 'Nantucket' },
            // Missing North Shore ZIPs
            '01944': { lat: 42.5778, lng: -70.7692, city: 'Manchester' },
            '01915': { lat: 42.5584, lng: -70.8800, city: 'Beverly' },
            '01945': { lat: 42.5001, lng: -70.8578, city: 'Marblehead' },
            '01960': { lat: 42.5278, lng: -70.9286, city: 'Peabody' },
            '01970': { lat: 42.5195, lng: -70.8967, city: 'Salem' },
            '01966': { lat: 42.5584, lng: -70.8800, city: 'Rockport' },
            '01982': { lat: 42.6167, lng: -70.9481, city: 'Hamilton' },
            '01983': { lat: 42.6167, lng: -70.9481, city: 'Topsfield' },
            '01929': { lat: 42.6334, lng: -70.9634, city: 'Essex' },
            '01930': { lat: 42.6334, lng: -70.9634, city: 'Gloucester' },
            '01938': { lat: 42.6334, lng: -70.9634, city: 'Ipswich' },
            '01950': { lat: 42.7928, lng: -70.8734, city: 'Newburyport' },
            '01951': { lat: 42.7928, lng: -70.8734, city: 'Newbury' },
            '01952': { lat: 42.5834, lng: -70.8578, city: 'Salisbury' },
            '01969': { lat: 42.5584, lng: -70.8800, city: 'Rowley' },
            '01984': { lat: 42.6584, lng: -70.8800, city: 'Wenham' },
            '01985': { lat: 42.6584, lng: -70.8800, city: 'West Newbury' }
        };

        // Time conversion functions (10-minute intervals)
        function sliderValueToTime(value) {
            const totalMinutes = value * 10;
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            const displayHours = hours === 0 ? 12 : (hours > 12 ? hours - 12 : hours);
            const period = hours < 12 ? 'AM' : 'PM';
            return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
        }

        // State management
        let monitoringInterval = null;
        let hasEverStartedMonitoring = false; // Track if monitoring has ever been started (for overlay behavior)
        let selectedCenters = new Set();
        let activeRegions = new Set();
        let sortMode = 'alphabetical';
        let centersWithDistance = null;
        let userZipCoords = null;
        let stats = {
            checks: 0,
            available: 0,
            notifications: 0,
            matching: 0
        };

        // Countdown timer variables
        let nextCheckTime = null;
        let countdownInterval = null;

        // Calculate distance between two coordinates using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 3959; // Radius of Earth in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // RMV Connection and Data Extraction
        let extractedPersonalData = null;
        
        function showSections() {
            // Show all hidden sections with fade-in animation
            const hiddenSections = document.querySelectorAll('.sections-hidden');
            hiddenSections.forEach((section, index) => {
                setTimeout(() => {
                    section.classList.remove('sections-hidden');
                    section.classList.add('section-fade-in');
                }, index * 200); // Stagger the animations
            });
        }

        async function connectToRMV() {
            // Prevent duplicate runs
            const connectBtn = document.getElementById('connectRMV');
            if (connectBtn.disabled) {
                console.log('⚠️ Connection already in progress, ignoring duplicate click');
                return;
            }

            const rmvUrl = document.getElementById('rmvUrl').value.trim();
            const zipCode = document.getElementById('zipCode').value.trim();
            
            if (!rmvUrl) {
                alert('Please enter your RMV scheduling URL');
                return;
            }

            if (!zipCode || !/^\d{5}$/.test(zipCode)) {
                alert('Please enter a valid 5-digit ZIP code');
                return;
            }

            if (!rmvUrl.includes('rmvmassdotappt.cxmflow.com')) {
                alert('Please enter a valid RMV appointment URL from rmvmassdotappt.cxmflow.com');
                return;
            }

            const loader = document.getElementById('extractionLoader');
            const successDiv = document.getElementById('extractionSuccess');
            const statusBadge = document.getElementById('connectionStatus');
            
            // Show loading state
            connectBtn.disabled = true;
            loader.style.display = 'block';
            successDiv.style.display = 'none';
            
            try {
                const response = await fetch('/api/extract-personal-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: rmvUrl })
                });

                if (response.ok) {
                    const result = await response.json();
                    extractedPersonalData = result.personalData;
                    
                    // Update UI with success
                    loader.style.display = 'none';
                    successDiv.style.display = 'block';
                    statusBadge.textContent = 'CONNECTED';
                    statusBadge.className = 'status-badge status-active';
                    
                    // Show other sections
                    showSections();
                    
                    // Update notification info with extracted data
                    updateNotificationInfo();
                    
                    // Scroll to next section
                    setTimeout(() => {
                        document.getElementById('section2').scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start' 
                        });
                    }, 1000);
                    
                } else {
                    // Try to get the error message from response
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Failed to extract personal data');
                }
                
            } catch (error) {
                console.error('RMV connection failed:', error);
                loader.style.display = 'none';
                
                // Show the specific error message from backend if available
                let errorMessage = error.message;
                if (errorMessage === 'Failed to extract personal data') {
                    errorMessage = 'Failed to connect to your RMV account. Please check your URL and try again.';
                }
                
                alert(errorMessage);
                connectBtn.disabled = false;
            }
        }

        // Initialize UI
        function initializeUI() {
            console.log('Initializing UI...');
            
            // Add RMV connection event listener
            const connectBtn = document.getElementById('connectRMV');
            console.log('Connect button found:', connectBtn);
            
            // Add event listener to RMV URL field for dynamic location discovery
            const rmvUrlField = document.getElementById('rmvUrl');
            if (rmvUrlField) {
                rmvUrlField.addEventListener('blur', discoverLocationsFromUrl);
                rmvUrlField.addEventListener('change', discoverLocationsFromUrl);
                console.log('Added location discovery listeners to RMV URL field');
            }
            if (connectBtn) {
                connectBtn.addEventListener('click', connectToRMV);
                connectBtn.setAttribute('data-listener-added', 'true');
                console.log('Connect button event listener added');
            }
            
            // Add ZIP code input listener for distance sorting
            const zipCodeField = document.getElementById('zipCode');
            console.log('ZIP code field found:', zipCodeField);
            if (zipCodeField) {
                zipCodeField.addEventListener('input', handleZipCodeInput);
                console.log('ZIP code event listener added');
            }
            
            // Initially populate service centers alphabetically
            populateServiceCenters();
            
            // Initialize regional mappings with default locations
            updateRegionalMappings();
            
            // Disable distance sorting initially (no ZIP entered)
            const distanceSort = document.getElementById('sortDistance');
            if (distanceSort) {
                distanceSort.disabled = true;
            }

            // Set default dates for time preferences
            const today = new Date();
            const endDate = new Date();
            endDate.setDate(today.getDate() + 30); // 30 days default

            const startDateEl = document.getElementById('startDate');
            const endDateEl = document.getElementById('endDate');
            
            if (startDateEl) startDateEl.value = today.toISOString().split('T')[0];
            if (endDateEl) endDateEl.value = endDate.toISOString().split('T')[0];

            // Initialize time sliders
            updateTimeDisplay();

            // Add event listeners for time sliders
            const startSlider = document.getElementById('startTimeSlider');
            const endSlider = document.getElementById('endTimeSlider');
            if (startSlider) startSlider.addEventListener('input', updateTimeDisplay);
            if (endSlider) endSlider.addEventListener('input', updateTimeDisplay);
            
            // Notification toggle listeners - only add if elements exist
            const emailNotifications = document.getElementById('emailNotifications');
            const smsNotifications = document.getElementById('smsNotifications');
            const pushNotifications = document.getElementById('pushNotifications');
            const webhookNotifications = document.getElementById('webhookNotifications');
            
            if (emailNotifications) emailNotifications.addEventListener('change', toggleNotificationInfo);
            if (smsNotifications) smsNotifications.addEventListener('change', toggleNotificationInfo);
            if (pushNotifications) pushNotifications.addEventListener('change', toggleNotificationInfo);
            if (webhookNotifications) webhookNotifications.addEventListener('change', toggleConditionalInput);

            // Request notification permission
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
            
            console.log('UI initialization completed');
        }

        // Populate service centers
        function populateServiceCenters(sortedCenters = null) {
            const centersContainer = document.getElementById('serviceCenters');
            centersContainer.innerHTML = '';
            
            const centers = sortedCenters || serviceCenters;
            centers.forEach(center => {
                const div = document.createElement('div');
                div.className = 'service-center';
                div.setAttribute('data-name', center.name || center);
                
                if (center.distance) {
                    div.innerHTML = `
                        ${center.name}
                        <div class="distance-badge">${Math.round(center.distance)}mi</div>
                    `;
                } else {
                    div.textContent = center.name || center;
                }
                
                div.onclick = () => toggleSelection(div, center.name || center);
                centersContainer.appendChild(div);
            });
        }

        // Handle ZIP code input
        function handleZipCodeInput() {
            const zipCode = document.getElementById('zipCode').value;
            const cityDisplay = document.getElementById('cityDisplay');
            
            console.log('ZIP code input:', zipCode, 'Length:', zipCode.length);
            
            if (zipCode.length === 5 && /^\d{5}$/.test(zipCode)) {
                console.log('Valid ZIP code detected, calling lookupZipCode');
                lookupZipCode(zipCode);
            } else if (zipCode.length === 0) {
                // Clear city when ZIP is removed
                cityDisplay.textContent = '';
                userZipCoords = null;
                centersWithDistance = null;
                // Reset to alphabetical sort
                setSortMode('alphabetical');
                addLog('ZIP code cleared - reset to alphabetical sorting', 'info');
            } else if (zipCode.length > 0 && zipCode.length < 5) {
                // Clear city while typing invalid ZIP
                cityDisplay.textContent = '';
            }
        }

        // Restore selections after repopulating centers
        function restoreSelections() {
            const serviceCenterElements = document.querySelectorAll('.service-center');
            serviceCenterElements.forEach(element => {
                const centerName = element.getAttribute('data-name');
                if (selectedCenters.has(centerName)) {
                    element.classList.add('selected');
                }
            });
        }

        // Set sort mode
        function setSortMode(mode) {
            sortMode = mode;
            
            // Update button states
            document.getElementById('sortAlphabetical').classList.toggle('active', mode === 'alphabetical');
            document.getElementById('sortDistance').classList.toggle('active', mode === 'distance');
            
            // Re-sort and update display
            if (mode === 'distance' && userZipCoords) {
                populateServiceCenters(centersWithDistance);
            } else {
                populateServiceCenters(serviceCenters); // Original alphabetical order
            }
            
            // Restore selections after repopulating
            restoreSelections();
            
            addLog(`Sort mode changed to: ${mode}`, 'info');
        }

        // Lookup ZIP code and update city, calculate distances
        function lookupZipCode(zipCode) {
            console.log('lookupZipCode called with:', zipCode);
            
            if (!zipCode || zipCode.length < 5) {
                document.getElementById('cityDisplay').textContent = '';
                userZipCoords = null;
                centersWithDistance = [];
                document.getElementById('sortDistance').disabled = true;
                if (sortMode === 'distance') {
                    setSortMode('alphabetical');
                }
                return;
            }
            
            console.log('Looking up ZIP:', zipCode, 'in zipCoords object');
            console.log('zipCoords[zipCode]:', zipCoords[zipCode]);
            
            // In production, this would call a real geocoding API
            if (zipCoords[zipCode]) {
                const coords = zipCoords[zipCode];
                console.log('Found coordinates:', coords);
                console.log('Setting city display to:', coords.city);
                document.getElementById('cityDisplay').textContent = coords.city;
                userZipCoords = coords;
                
                // Calculate distances and sort service centers
                centersWithDistance = serviceCenters.map(center => ({
                    ...center,
                    distance: calculateDistance(coords.lat, coords.lng, center.lat, center.lng)
                })).sort((a, b) => a.distance - b.distance);
                
                // Enable distance sorting
                document.getElementById('sortDistance').disabled = false;
                
                // Log distances
                console.log('Service center distances from', zipCode + ':', coords.city);
                centersWithDistance.forEach(center => {
                    console.log(`${center.name} (${center.address}): ${Math.round(center.distance)} miles`);
                });
                
                // Update UI based on current sort mode
                if (sortMode === 'distance') {
                    populateServiceCenters(centersWithDistance);
                }
                
                addLog(`ZIP ${zipCode} found: ${coords.city}. Distance sorting enabled.`, 'info');
            } else {
                // Handle unknown ZIP - clear city and keep alphabetical
                document.getElementById('cityDisplay').textContent = '';
                userZipCoords = null;
                centersWithDistance = [];
                document.getElementById('sortDistance').disabled = true;
                
                if (sortMode === 'distance') {
                    setSortMode('alphabetical');
                }
                
                addLog(`ZIP code ${zipCode} not found. Distance sorting disabled.`, 'info');
            }
        }

        // Regional selection with replacement logic
        function selectRegion(regionKey) {
            const regionButton = event.target;
            
            if (regionKey === 'none') {
                selectedCenters.clear();
                activeRegions.clear();
                document.querySelectorAll('.service-center').forEach(el => {
                    el.classList.remove('selected');
                });
                document.querySelectorAll('.btn-region:not(.btn-clear)').forEach(btn => {
                    btn.classList.remove('active');
                });
                addLog('Cleared all service center selections', 'info');
            } else if (regions[regionKey]) {
                // Check if this region is already active
                if (activeRegions.has(regionKey)) {
                    // Deactivate current region
                    activeRegions.delete(regionKey);
                    regionButton.classList.remove('active');
                    regions[regionKey].forEach(centerName => {
                        const element = document.querySelector(`[data-name="${centerName}"]`);
                        if (element) {
                            element.classList.remove('selected');
                            selectedCenters.delete(centerName);
                        }
                    });
                    addLog(`Deselected ${regions[regionKey].length} centers in ${regionKey} region`, 'info');
                } else {
                    // NEW REGION REPLACEMENT LOGIC:
                    // Clear all previously selected regions and centers first
                    const previouslyActiveRegions = Array.from(activeRegions);
                    
                    // Clear all previous selections
                    selectedCenters.clear();
                    activeRegions.clear();
                    document.querySelectorAll('.service-center').forEach(el => {
                        el.classList.remove('selected');
                    });
                    document.querySelectorAll('.btn-region:not(.btn-clear)').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Now activate the new region
                    const regionCenters = regions[regionKey].filter(centerName => {
                        // Only include centers that actually exist in the current serviceCenters
                        return serviceCenters.some(center => (center.name || center) === centerName);
                    });
                    
                    if (regionCenters.length === 0) {
                        addLog(`⚠️ No locations available in ${regionKey} region with current location set`, 'warning');
                        return;
                    }
                    
                    // Activate the new region
                    activeRegions.add(regionKey);
                    regionButton.classList.add('active');
                    regionCenters.forEach(centerName => {
                        const element = document.querySelector(`[data-name="${centerName}"]`);
                        if (element) {
                            element.classList.add('selected');
                            selectedCenters.add(centerName);
                        }
                    });
                    
                    if (previouslyActiveRegions.length > 0) {
                        addLog(`🔄 Replaced ${previouslyActiveRegions.join('/')} region${previouslyActiveRegions.length > 1 ? 's' : ''} with ${regionKey} (${regionCenters.length} locations)`, 'info');
                    } else {
                        addLog(`✅ Selected ${regionCenters.length} centers in ${regionKey} region`, 'info');
                    }
                }
            }
        }

        // Update notification info displays
        // Format phone input
        function formatPhoneInput(event) {
            let value = event.target.value.replace(/\D/g, ''); // Remove non-digits
            
            if (value.length >= 6) {
                value = '(' + value.slice(0, 3) + ') ' + value.slice(3, 6) + '-' + value.slice(6, 10);
            } else if (value.length >= 3) {
                value = '(' + value.slice(0, 3) + ') ' + value.slice(3);
            }
            
            event.target.value = value;
            updateNotificationInfo();
        }

        function updateNotificationInfo() {
            // Use extracted personal data if available, otherwise fallback to empty state
            const email = extractedPersonalData?.email || '';
            const phone = extractedPersonalData?.phone || '';
            
            document.getElementById('emailDisplay').textContent = email || '(connect RMV account to auto-fill)';
            document.getElementById('phoneDisplay').textContent = phone || '(connect RMV account to auto-fill)';
        }

        // Toggle notification info visibility
        function toggleNotificationInfo(event) {
            const notificationType = event.target.id.replace('Notifications', '');
            const infoElement = document.getElementById(notificationType + 'Info');
            
            if (event.target.checked) {
                infoElement.classList.add('show');
                if (notificationType === 'email' || notificationType === 'sms') {
                    updateNotificationInfo();
                }
            } else {
                infoElement.classList.remove('show');
            }
        }

        function updateTimeDisplay() {
            const startValue = document.getElementById('startTimeSlider').value;
            const endValue = document.getElementById('endTimeSlider').value;
            
            document.getElementById('startTimeDisplay').textContent = sliderValueToTime(startValue);
            document.getElementById('endTimeDisplay').textContent = sliderValueToTime(endValue);

            // Ensure start time is not after end time
            if (parseInt(startValue) >= parseInt(endValue)) {
                document.getElementById('endTimeSlider').value = parseInt(startValue) + 1;
                document.getElementById('endTimeDisplay').textContent = sliderValueToTime(parseInt(startValue) + 1);
            }
        }

        function toggleConditionalInput() {
            const webhookInfo = document.getElementById('webhookInfo');
            const isChecked = document.getElementById('webhookNotifications').checked;
            
            if (isChecked) {
                webhookInfo.classList.add('show');
            } else {
                webhookInfo.classList.remove('show');
            }
        }

        // Toggle selection for service centers (max 8)
        function toggleSelection(element, value) {
            if (selectedCenters.has(value)) {
                // Deselecting - always allowed
                element.classList.remove('selected');
                selectedCenters.delete(value);
            } else {
                // Selecting - check maximum limit
                if (selectedCenters.size >= 8) {
                    alert('Maximum 8 locations selected. Please deselect some locations first.');
                    return;
                }
                element.classList.add('selected');
                selectedCenters.add(value);
            }
        }

        // Add log entry
        function addLog(message, type = 'info') {
            const userFriendlyMessage = makeLogUserFriendly(message, type);
            
            // Skip technical messages that aren't useful to users
            if (userFriendlyMessage === null) {
                return;
            }
            
            const log = document.getElementById('monitorLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${userFriendlyMessage}`;
            log.insertBefore(entry, log.firstChild);

            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.lastChild);
            }
        }

        // Convert technical logs to user-friendly messages
        function makeLogUserFriendly(message, type) {
            // Skip overly technical messages
            if (message.includes('Session ID:') || 
                message.includes('Using session') ||
                message.includes('Old monitoring sessions cleared') ||
                message.includes('Sort mode changed') ||
                message.includes('ZIP code cleared')) {
                return null;
            }
            
            // Convert technical messages to user-friendly ones
            if (message.includes('Backend monitoring') && message.includes('service centers')) {
                const count = message.match(/(\d+)/)?.[1] || 'multiple';
                return `🔍 Monitoring ${count} service centers for appointments`;
            }
            
            if (message.includes('Backend will check every 5 minutes')) {
                return `⏱️ System will check for new appointments automatically every 5 minutes`;
            }
            
            if (message.includes('Backend found') && message.includes('appointments')) {
                const count = message.match(/(\d+)/)?.[1] || 'some';
                return `✅ Found ${count} available appointments! Check calendar/list view above`;
            }
            
            if (message.includes('Found') && message.includes('appointments across') && message.includes('locations')) {
                const appointmentCount = message.match(/Found (\d+)/)?.[1] || 'multiple';
                const locationCount = message.match(/across (\d+)/)?.[1] || 'multiple';
                return `🎯 Discovered ${appointmentCount} appointments across ${locationCount} locations`;
            }
            
            if (message.includes('No appointments available at') && message.includes('locations')) {
                const locationCount = message.match(/(\d+)/)?.[1] || 'selected';
                return `😕 No appointments currently available at ${locationCount} locations - will check again in 5 minutes`;
            }
            
            if (message.includes('Email notification sent')) {
                const email = extractedPersonalData?.email || 'your email';
                return `📧 Appointment alert sent to ${email}`;
            }
            
            if (message.includes('SMS notification sent')) {
                const phone = extractedPersonalData?.phone || 'your phone';
                return `📱 Text message alert sent to ${phone}`;
            }
            
            if (message.includes('Webhook notification sent')) {
                return `🔗 Webhook notification sent to your custom endpoint`;
            }
            
            if (message.includes('Last checked:')) {
                const time = message.split('Last checked: ')[1];
                return `🕐 Last appointment check completed at ${time}`;
            }
            
            if (message.includes('ZIP') && message.includes('found') && message.includes('Distance sorting enabled')) {
                const zipMatch = message.match(/ZIP (\d+)/)?.[1];
                const cityMatch = message.match(/found: ([^.]+)/)?.[1];
                return `📍 ZIP ${zipMatch} located: ${cityMatch} - locations sorted by distance`;
            }
            
            if (message.includes('Selected') && message.includes('centers in') && message.includes('region')) {
                const countMatch = message.match(/Selected (\d+)/)?.[1];
                const regionMatch = message.match(/centers in ([^(]+)/)?.[1];
                const totalMatch = message.match(/Total: (\d+)\/8/)?.[1];
                return `✅ Selected ${countMatch} centers in ${regionMatch?.trim()} (${totalMatch}/8 total)`;
            }
            
            if (message.includes('Deselected') && message.includes('centers in') && message.includes('region')) {
                const countMatch = message.match(/Deselected (\d+)/)?.[1];
                const regionMatch = message.match(/centers in ([^r]+) region/)?.[1];
                return `❌ Deselected ${countMatch} centers in ${regionMatch?.trim()}`;
            }
            
            if (message.includes('Cleared all service center selections')) {
                return `🧹 Cleared all location selections`;
            }
            
            if (message.includes('Monitoring started successfully')) {
                return `🚀 Monitoring started! System is now checking for appointments`;
            }
            
            if (message.includes('Monitoring stopped successfully')) {
                return `⏹️ Monitoring stopped`;
            }
            
            if (message.includes('Backend session') && message.includes('terminated')) {
                return `🔒 Monitoring session ended successfully`;
            }

            // Handle expired URL scenario (like after booking)
            if (message.includes('No appointments available at 0 locations') || 
                (message.includes('Found 0 appointments') && message.includes('locations'))) {
                return `ℹ️ RMV session expired (this usually means you successfully booked or the URL is no longer valid)`;
            }
            
            // Return original message for unmatched cases (keep important user messages)
            return message;
        }

        // Clear log
        function clearLog() {
            const log = document.getElementById('monitorLog');
            log.innerHTML = '<div class="log-entry info">Log cleared.</div>';
        }

        // Validate form
        function validateForm() {
            // Check if personal data has been extracted (Section 1)
            if (!extractedPersonalData) {
                alert('⚠️ Please connect your RMV account first in Section 1');
                addLog('Please connect your RMV account first in Section 1', 'error');
                document.getElementById('section1').scrollIntoView({ behavior: 'smooth' });
                return false;
            }

            // Check required fields that still exist
            const rmvUrl = document.getElementById('rmvUrl').value.trim();
            const zipCode = document.getElementById('zipCode').value.trim();
            
            if (!rmvUrl) {
                alert('⚠️ Please enter your RMV scheduling URL in Section 1');
                addLog('Please fill in RMV URL', 'error');
                document.getElementById('rmvUrl').focus();
                return false;
            }

            if (!zipCode) {
                alert('⚠️ Please enter your ZIP code in Section 1');
                addLog('Please fill in ZIP Code', 'error');
                document.getElementById('zipCode').focus();
                return false;
            }

            // Validate ZIP code format
            if (!/^\d{5}$/.test(zipCode)) {
                alert('⚠️ Please enter a valid 5-digit ZIP code in Section 1');
                addLog('Please enter a valid 5-digit ZIP code in Section 1', 'error');
                document.getElementById('zipCode').focus();
                return false;
            }

            // Check if service centers are selected (Section 2)
            if (selectedCenters.size === 0) {
                alert('⚠️ Please select at least one RMV service center in Section 2');
                addLog('Please select at least one service center from Section 2', 'error');
                document.getElementById('section2').scrollIntoView({ behavior: 'smooth' });
                return false;
            }

            // Validate URL format
            if (!rmvUrl.includes('massdot.state.ma.us') && !rmvUrl.includes('cxmflow.com')) {
                addLog('Please enter a valid RMV booking URL (should contain massdot.state.ma.us or cxmflow.com)', 'error');
                return false;
            }

            // Link expiration validation removed - no longer needed with automatic extraction

            return true;
        }

        // Global session ID for tracking monitoring session
        let currentMonitoringSessionId = null;
        let resultsPollingInterval = null;

        // Helper functions to manage loading states for both calendar and list views
        function showLoadingStates() {
            // Hide inactive states
            const inactiveEl = document.getElementById('appointmentsInactive');
            if (inactiveEl) inactiveEl.style.display = 'none';
            
            const calendarInactiveEl = document.getElementById('calendarInactive');
            if (calendarInactiveEl) calendarInactiveEl.style.display = 'none';
            
            // Show loading states
            const loadingEl = document.getElementById('appointmentsLoading');
            if (loadingEl) loadingEl.style.display = 'block';
            
            const calendarLoadingEl = document.getElementById('calendarLoading');
            if (calendarLoadingEl) calendarLoadingEl.style.display = 'block';
            
            // Hide content views
            const listEl = document.getElementById('appointmentsList');
            if (listEl) listEl.style.display = 'none';
            
            const calendarEl = document.getElementById('calendarView');
            if (calendarEl) calendarEl.style.display = 'none';
        }

        function hideLoadingStates() {
            // Hide loading states
            const loadingEl = document.getElementById('appointmentsLoading');
            if (loadingEl) loadingEl.style.display = 'none';
            
            const calendarLoadingEl = document.getElementById('calendarLoading');
            if (calendarLoadingEl) calendarLoadingEl.style.display = 'none';
        }

        function showAppointmentResults() {
            hideLoadingStates();
            
            // Show content based on current view
            const isCalendarView = document.getElementById('calendarViewContent').style.display !== 'none';
            
            if (isCalendarView) {
                const calendarEl = document.getElementById('calendarView');
                if (calendarEl) calendarEl.style.display = 'block';
            } else {
                const listEl = document.getElementById('appointmentsList');
                if (listEl) listEl.style.display = 'block';
            }
        }

        // Start monitoring with backend session
        async function startMonitoring() {
            if (!validateForm()) return;

            // Update UI immediately - new layout
            const startMonitoringSection = document.getElementById('startMonitoringSection');
            const appointmentsLoading = document.getElementById('appointmentsLoading');
            const stopMonitoringSection = document.getElementById('stopMonitoringSection');
            const viewToggleContainer = document.getElementById('viewToggleContainer');
            const monitorStatus = document.getElementById('monitorStatus');
            const subInstruction = document.getElementById('monitoringSubInstruction');
            
            // Mark that monitoring has been started and remove absolute positioning if needed
            hasEverStartedMonitoring = true;
            
            // Remove absolute positioning and hide start section, show loading
            if (startMonitoringSection) {
                startMonitoringSection.style.position = 'static';
                startMonitoringSection.style.display = 'none';
            }
            if (appointmentsLoading) appointmentsLoading.style.display = 'block';
            if (stopMonitoringSection) stopMonitoringSection.style.display = 'block';
            
            // Update status badge
            if (monitorStatus) {
                monitorStatus.textContent = 'ACTIVE';
                monitorStatus.className = 'status-badge status-active';
            }
            
            // Update sub-instruction to show monitoring active
            if (subInstruction) {
                subInstruction.textContent = 'Monitoring active. Checking for appointments every 5 minutes. Results will appear below when found.';
            }
            
            // Keep tabs disabled during initial search
            if (viewToggleContainer) {
                viewToggleContainer.style.opacity = '0.5';
                viewToggleContainer.style.pointerEvents = 'none';
            }
            
            // Show appointments loading state for both views (existing code)
            showLoadingStates();

            const startTime = sliderValueToTime(document.getElementById('startTimeSlider').value);
            const endTime = sliderValueToTime(document.getElementById('endTimeSlider').value);

            try {
                // Register monitoring session with backend
                const response = await fetch('/api/start-monitoring', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rmvUrl: document.getElementById('rmvUrl').value,
                        selectedCenters: Array.from(selectedCenters),
                        preferences: {
                            startTime: startTime,
                            endTime: endTime,
                            startDate: document.getElementById('startDate').value,
                            endDate: document.getElementById('endDate').value,
                            locations: Array.from(selectedCenters)
                        },
                        personalData: extractedPersonalData || {}
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    currentMonitoringSessionId = result.sessionId;
                    
                    addLog('Monitoring started successfully', 'success');
                    addLog(`Session ID: ${result.sessionId}`, 'info');
                    addLog(`Backend monitoring ${result.locationsCount} service centers`, 'info');
                    addLog(`Preferred time window: ${startTime} - ${endTime}`, 'info');
                    addLog('Backend will check every 5 minutes automatically', 'info');

                    // Show appointments section
                    document.getElementById('section5').style.display = 'block';
                    
                    // Start countdown timer for next check
                    startCountdownTimer();
                    
                    // Start polling for results from backend every 30 seconds
                    startResultsPolling();
                    
                    // Aggressive polling for FAST scraping (should complete in 5-8 seconds)
                    setTimeout(pollForResults, 2000);  // 2 seconds (early check)
                    setTimeout(pollForResults, 4000);  // 4 seconds (mid-process)  
                    setTimeout(pollForResults, 6000);  // 6 seconds (should be complete)
                    setTimeout(pollForResults, 8000);  // 8 seconds (safety check)
                    setTimeout(pollForResults, 12000); // 12 seconds (final fallback)
                    
                } else {
                    throw new Error(result.error || 'Failed to start monitoring');
                }

            } catch (error) {
                addLog(`Failed to start monitoring: ${error.message}`, 'error');
                
                // Reset UI on error
                if (startBtn) startBtn.style.display = 'inline-block';
                if (stopBtn) stopBtn.style.display = 'none';
                if (monitorStatus) {
                    monitorStatus.textContent = 'INACTIVE';
                    monitorStatus.className = 'status-badge status-inactive';
                }
            }
        }

        // Stop monitoring with backend session
        async function stopMonitoring() {
            // Stop polling for results
            if (resultsPollingInterval) {
                clearInterval(resultsPollingInterval);
                resultsPollingInterval = null;
            }

            // Clear old intervals (if any)
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }

            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            // Reset countdown display
            nextCheckTime = null;
            const countdownElement = document.getElementById('nextCheckCountdown');
            if (countdownElement) {
                countdownElement.textContent = '--';
            }

            // Stop backend monitoring session
            if (currentMonitoringSessionId) {
                try {
                    const response = await fetch('/api/stop-monitoring', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sessionId: currentMonitoringSessionId
                        })
                    });

                    const result = await response.json();
                    
                    if (result.success) {
                        addLog('Monitoring stopped successfully', 'info');
                        addLog(`Backend session ${currentMonitoringSessionId} terminated`, 'info');
                    } else {
                        addLog(`Warning: ${result.message}`, 'warn');
                    }
                } catch (error) {
                    addLog(`Error stopping monitoring: ${error.message}`, 'error');
                }
                
                currentMonitoringSessionId = null;
            }

            // Update UI - NEW LAYOUT
            const startMonitoringSection = document.getElementById('startMonitoringSection');
            const appointmentsLoading = document.getElementById('appointmentsLoading');
            const stopMonitoringSection = document.getElementById('stopMonitoringSection');
            const viewToggleContainer = document.getElementById('viewToggleContainer');
            const monitorStatus = document.getElementById('monitorStatus');
            const subInstruction = document.getElementById('monitoringSubInstruction');
            const listViewContent = document.getElementById('listViewContent');
            const calendarViewContent = document.getElementById('calendarViewContent');
            
            // Show start monitoring section (use normal flow since monitoring has been started before)
            if (startMonitoringSection) {
                // Keep static positioning since this is no longer initial state
                startMonitoringSection.style.position = 'static';
                startMonitoringSection.style.display = 'block';
            }
            if (appointmentsLoading) appointmentsLoading.style.display = 'none';
            if (stopMonitoringSection) stopMonitoringSection.style.display = 'none';
            
            // Show appropriate content view (monitoring has been started, so views should be visible)
            if (listViewContent) listViewContent.style.display = 'none';
            if (calendarViewContent) calendarViewContent.style.display = 'block';
            
            // Keep tabs enabled since monitoring has been started before (user can view previous results)
            if (viewToggleContainer) {
                viewToggleContainer.style.opacity = '1';
                viewToggleContainer.style.pointerEvents = 'auto';
            }
            
            // Reset status badge
            if (monitorStatus) {
                monitorStatus.textContent = 'INACTIVE';
                monitorStatus.className = 'status-badge status-inactive';
            }
            
            // Update sub-instruction (monitoring has been used, so mention restarting)
            if (subInstruction) {
                subInstruction.textContent = 'Monitoring stopped. Click "Start Monitoring" below to resume checking for appointments.';
            }
        }

        // Poll backend for monitoring results (one-time)
        async function pollForResults() {
            try {
                const response = await fetch('/api/monitoring-status');
                const status = await response.json();
                
                console.log('🔍 Polling results:', status);
                console.log('🔍 Current session ID we are looking for:', currentMonitoringSessionId);
                console.log('🔍 All available sessions:', status.sessions.map(s => ({id: s.sessionId, appointments: s.appointmentsFound})));
                
                if (status.success && status.sessions.length > 0) {
                    // Since we now clear old sessions, there should only be one active session
                    let mySession = status.sessions.find(s => s.sessionId === currentMonitoringSessionId);
                    console.log('🔍 Found our session by ID:', mySession ? `${mySession.sessionId} (${mySession.appointmentsFound} appointments)` : 'NOT FOUND');
                    
                    if (!mySession && status.sessions.length > 0) {
                        // Use the first (and should be only) session
                        mySession = status.sessions[0];
                        currentMonitoringSessionId = mySession.sessionId;
                        addLog(`Using session ${mySession.sessionId} (${mySession.appointmentsFound} appointments)`, 'info');
                    }
                    
                    console.log('🔍 Final selected session:', mySession ? `${mySession.sessionId} (${mySession.appointmentsFound} appointments)` : 'NULL');
                    console.log('🔍 Session data:', mySession);
                    console.log('🔍 appointmentsFound:', mySession?.appointmentsFound);
                    console.log('🔍 appointments array length:', mySession?.appointments?.length);
                    console.log('🔍 appointments sample:', mySession?.appointments?.[0]);
                    
                    if (mySession && mySession.appointmentsFound > 0) {
                        addLog(`Backend found ${mySession.appointmentsFound} appointments!`, 'success');
                        
                        // Display the appointments from backend
                        if (mySession.appointments && mySession.appointments.length > 0) {
                            displayAppointments(mySession.appointments);
                            stats.available = mySession.appointmentsFound;
                            updateStats();
                            
                            // Hide loading state and show results
                            const loadingEl = document.getElementById('appointmentsLoading');
                            const listEl = document.getElementById('appointmentsList');
                            
                            if (loadingEl) {
                                loadingEl.style.display = 'none';
                            } else {
                                console.warn('appointmentsLoading element not found');
                            }
                            
                            if (listEl) {
                                listEl.style.display = 'block';
                            } else {
                                console.warn('appointmentsList element not found');
                            }
                        }
                    } else if (mySession && mySession.appointmentsFound === 0) {
                        // Only show "no appointments" if the session has actually been checked (has lastChecked timestamp)
                        if (mySession.lastChecked) {
                            displayNoAppointments();
                        } else {
                            // Session exists but hasn't been checked yet - keep loading spinner
                            console.log('⏳ Session exists but not yet processed, keeping loading spinner...');
                        }
                    }
                    
                    // Update last checked time
                    if (mySession && mySession.lastChecked) {
                        const lastChecked = new Date(mySession.lastChecked);
                        addLog(`Last checked: ${lastChecked.toLocaleTimeString()}`, 'info');
                    }
                }
            } catch (error) {
                console.error('Error polling monitoring status:', error);
            }
        }

        // Poll backend for monitoring results (continuous)
        function startResultsPolling() {
            // Check for results based on current time schedule
            // 5 minutes during business hours (9AM-5PM), 30 minutes off-hours
            const pollInterval = getCheckInterval();
            resultsPollingInterval = setInterval(pollForResults, pollInterval);
        }

        // Get check interval based on current time
        function getCheckInterval() {
            const now = new Date();
            const hour = now.getHours();

            // Check every 5 minutes during business hours, every 30 minutes otherwise
            if (hour >= 9 && hour <= 16) {
                return 5 * 60 * 1000; // 5 minutes
            } else {
                return 30 * 60 * 1000; // 30 minutes
            }
        }

        // Check appointments (mock implementation)
        async function checkAppointments() {
            stats.checks++;
            updateStats();

            const rmvUrl = document.getElementById('rmvUrl').value;
            addLog(`Checking appointments for ${selectedCenters.size} centers at ${rmvUrl}`, 'info');

            // Get live appointment data from RMV system
            const rmvCheckResults = await checkRMVAppointments();

            if (rmvCheckResults.found) {
                stats.available += rmvCheckResults.appointments.length;
                updateStats();

                addLog(`Found ${rmvCheckResults.appointments.length} available appointments!`, 'success');

                // Send notifications
                await sendNotifications(rmvCheckResults.appointments);

                // Display appointments with preference highlighting
                displayAppointments(rmvCheckResults.appointments);
            } else {
                addLog('No appointments available at this time', 'info');
                displayNoAppointments();
            }
        }

        // Live RMV appointment checking (replaces mock data)
        async function checkRMVAppointments() {
            const rmvUrl = document.getElementById('rmvUrl').value;
            const selectedCentersList = Array.from(selectedCenters);
            
            addLog('Starting RMV appointment extraction...', 'info');
            
            try {
                // Call backend scraping service
                const response = await fetch('/api/scrape-rmv-appointments', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        rmvUrl: rmvUrl,
                        selectedCenters: selectedCentersList,
                        preferences: {
                            startDate: document.getElementById('startDate').value,
                            endDate: document.getElementById('endDate').value,
                            startTime: sliderValueToTime(document.getElementById('startTimeSlider').value),
                            endTime: sliderValueToTime(document.getElementById('endTimeSlider').value)
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                
                if (result.error) {
                    addLog(`Scraping error: ${result.error}`, 'error');
                    return { found: false, appointments: [], error: result.error };
                }

                if (result.appointments && result.appointments.length > 0) {
                    addLog(`Found ${result.appointments.length} appointments across ${result.locationsChecked} locations`, 'success');
                    return { 
                        found: true, 
                        appointments: result.appointments,
                        locationsChecked: result.locationsChecked
                    };
                } else {
                    addLog(`No appointments available at ${result.locationsChecked || selectedCentersList.length} locations`, 'info');
                    return { found: false, appointments: [], locationsChecked: result.locationsChecked };
                }

            } catch (error) {
                addLog(`Failed to check appointments: ${error.message}`, 'error');
                return { found: false, appointments: [], error: error.message };
            }
        }

        // Send notifications
        async function sendNotifications(appointments) {
            const emailEnabled = document.getElementById('emailNotifications').checked;
            const smsEnabled = document.getElementById('smsNotifications').checked;
            const pushEnabled = document.getElementById('pushNotifications').checked;
            const webhookEnabled = document.getElementById('webhookNotifications').checked;
            const webhookUrl = document.getElementById('webhookUrl').value;

            // Browser push notification
            if (pushEnabled && 'Notification' in window && Notification.permission === 'granted') {
                const notification = new Notification('RMV Appointments Available!', {
                    body: `Found ${appointments.length} appointments matching your criteria`,
                    icon: '/icon-192x192.png',
                    badge: '/badge-72x72.png',
                    vibrate: [200, 100, 200]
                });

                notification.onclick = () => {
                    window.focus();
                    notification.close();
                };
            }

            // Log notification sending (actual implementation would send real notifications)
            if (emailEnabled) {
                addLog(`Email notification sent to ${extractedPersonalData?.email || 'user'}`, 'success');
                stats.notifications++;
            }

            if (smsEnabled) {
                addLog(`SMS notification sent to ${extractedPersonalData?.phone || 'user'}`, 'success');
                stats.notifications++;
            }

            if (webhookEnabled && webhookUrl) {
                try {
                    addLog(`Webhook notification sent to ${webhookUrl}`, 'success');
                    stats.notifications++;
                } catch (error) {
                    addLog(`Failed to send webhook notification: ${error.message}`, 'error');
                }
            }

            updateStats();
        }


        // Display appointments with distance-based priority and date grouping
        function displayAppointments(appointments) {
            console.log('📅 Display: Called with appointments:', appointments);
            console.log('📅 Display: Appointments count:', appointments?.length);
            console.log('📅 Display: Sample appointment:', appointments?.[0]);
            
            // NEW LAYOUT: Switch from loading to results
            const appointmentsLoading = document.getElementById('appointmentsLoading');
            const viewToggleContainer = document.getElementById('viewToggleContainer');
            const subInstruction = document.getElementById('monitoringSubInstruction');
            
            // Hide loading spinner
            if (appointmentsLoading) appointmentsLoading.style.display = 'none';
            
            // Enable tabs and show appropriate view
            if (viewToggleContainer) {
                viewToggleContainer.style.opacity = '1';
                viewToggleContainer.style.pointerEvents = 'auto';
            }
            
            // Update sub-instruction with countdown
            if (subInstruction) {
                subInstruction.innerHTML = `Monitoring active. Found <strong>${appointments?.length || 0} appointments</strong>. Next check in: <span id="nextCheckCountdown">--</span>`;
            }
            
            // Show the current active view (calendar is default)
            const calendarBtn = document.getElementById('calendarViewBtn');
            const listBtn = document.getElementById('listViewBtn');
            
            if (calendarBtn && calendarBtn.classList.contains('active')) {
                switchToCalendarView();
            } else if (listBtn && listBtn.classList.contains('active')) {
                switchToListView();
            } else {
                // Default to calendar view
                switchToCalendarView();
            }
            
            const container = document.getElementById('appointmentsContainer');
            
            if (!appointments || appointments.length === 0) {
                console.log('📅 Display: No appointments to display');
                displayNoAppointments();
                return;
            }

            // Save current expanded state before rebuilding
            const expandedSections = new Set();
            const existingSections = container.querySelectorAll('.other-group .appointments-grid:not(.collapsed)');
            existingSections.forEach(grid => {
                const header = grid.previousElementSibling;
                if (header && header.classList.contains('collapsible')) {
                    // Create unique identifier for this section
                    const dateSection = header.closest('.date-section');
                    const dateLabel = dateSection ? dateSection.querySelector('.date-label').textContent : '';
                    expandedSections.add(dateLabel);
                }
            });

            // Get user preferences
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            const startTimeSlider = document.getElementById('startTimeSlider').value;
            const endTimeSlider = document.getElementById('endTimeSlider').value;
            
            // Get user's ZIP code for distance priority calculation
            const userZip = document.getElementById('zipCode').value;
            
            // Define distance priority - this should eventually use actual distances
            // For now, using common ZIP-based priorities for Greater Boston area
            let distancePriority = {};
            if (userZip.startsWith('01944')) {
                // North Shore (Marblehead area)
                distancePriority = { 'Danvers': 1, 'Wilmington': 2, 'Haverhill': 3, 'Lawrence': 4, 'Lowell': 5 };
            } else if (userZip.startsWith('021')) {
                // Boston area
                distancePriority = { 'Wilmington': 1, 'Lawrence': 2, 'Lowell': 3, 'Haverhill': 4, 'Danvers': 5 };
            } else {
                // Default ordering
                distancePriority = { 'Danvers': 1, 'Haverhill': 2, 'Lawrence': 3, 'Lowell': 4, 'Wilmington': 5 };
            }
            
            // Add distance priority and preference flag to each appointment
            const processedAppointments = appointments.map(apt => {
                const aptDate = new Date(apt.date);
                const aptTime = timeToSliderValue(apt.time);
                const locationName = apt.center.split(/[0-9]/)[0]; // Extract location name
                
                const matchesTimePrefs = aptTime >= startTimeSlider && aptTime <= endTimeSlider;
                const matchesDatePrefs = aptDate >= startDate && aptDate <= endDate;
                const isPreferred = matchesTimePrefs && matchesDatePrefs;
                
                console.log(`📅 Preference check for ${apt.date} ${apt.time}:`, {
                    aptDate: aptDate.toDateString(),
                    startDate: startDate.toDateString(),
                    endDate: endDate.toDateString(),
                    aptTime,
                    startTimeSlider,
                    endTimeSlider,
                    matchesTimePrefs,
                    matchesDatePrefs,
                    isPreferred
                });
                
                if (isPreferred) stats.matching++;
                
                return {
                    ...apt,
                    isPreferred,
                    distancePriority: distancePriority[locationName] || 99,
                    locationName,
                    aptDate
                };
            });
            
            // Update calendar with processed appointments (now they have isPreferred property)
            updateCalendarData(processedAppointments);
            
            
            showCalendarView();
            
            // Check for notifications (only if browser push is enabled)
            const browserPushCheckbox = document.getElementById('browserPush');
            if (browserPushCheckbox && browserPushCheckbox.checked) {
                checkAndNotifyAppointments(processedAppointments);
            }
            
            updateStats();
            
            // Group by date
            const appointmentsByDate = {};
            processedAppointments.forEach(apt => {
                const dateKey = apt.date;
                if (!appointmentsByDate[dateKey]) {
                    appointmentsByDate[dateKey] = { preferred: [], other: [] };
                }
                
                if (apt.isPreferred) {
                    appointmentsByDate[dateKey].preferred.push(apt);
                } else {
                    appointmentsByDate[dateKey].other.push(apt);
                }
            });
            
            // Sort dates chronologically
            const sortedDates = Object.keys(appointmentsByDate).sort((a, b) => {
                return new Date(a) - new Date(b);
            });
            
            // Create display container
            const groupedContainer = document.createElement('div');
            groupedContainer.className = 'appointments-by-date';
            
            sortedDates.forEach(dateKey => {
                const dateGroup = appointmentsByDate[dateKey];
                
                // Sort by distance priority within each group
                dateGroup.preferred.sort((a, b) => a.distancePriority - b.distancePriority);
                dateGroup.other.sort((a, b) => a.distancePriority - b.distancePriority);
                
                // Create date section
                const dateSection = createDateSection(dateKey, dateGroup.preferred, dateGroup.other);
                groupedContainer.appendChild(dateSection);
            });
            
            container.innerHTML = '';
            container.appendChild(groupedContainer);
            
            // Restore expanded state after DOM rebuild
            setTimeout(() => {
                expandedSections.forEach(dateLabel => {
                    const dateSection = Array.from(container.querySelectorAll('.date-section')).find(section => {
                        const label = section.querySelector('.date-label');
                        return label && label.textContent === dateLabel;
                    });
                    
                    if (dateSection) {
                        const otherHeader = dateSection.querySelector('.other-group .collapsible');
                        if (otherHeader) {
                            const grid = otherHeader.nextElementSibling;
                            const toggle = otherHeader.querySelector('.toggle');
                            
                            grid.classList.remove('collapsed');
                            toggle.textContent = '▲';
                        }
                    }
                });
            }, 50); // Small delay to ensure DOM is fully rendered
            
            // Show appointment results (hides loading states and shows appropriate view)
            showAppointmentResults();
        }

        // Create collapsible date section with preferred/other groups
        function createDateSection(dateKey, preferredApts, otherApts) {
            const section = document.createElement('div');
            section.className = 'date-section';
            
            // Format date for display
            const date = new Date(dateKey);
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            
            let dateLabel;
            if (date.toDateString() === today.toDateString()) {
                dateLabel = `Today, ${date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}`;
            } else if (date.toDateString() === tomorrow.toDateString()) {
                dateLabel = `Tomorrow, ${date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}`;
            } else {
                dateLabel = date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
            }
            
            // Create header
            const header = document.createElement('div');
            header.className = 'date-section-header';
            header.innerHTML = `
                <div class="date-label">📅 ${dateLabel}</div>
                <div class="date-counts">${preferredApts.length + otherApts.length} appointments${preferredApts.length > 0 ? ` • ${preferredApts.length} preferred` : ''}</div>
            `;
            
            // Create content container
            const content = document.createElement('div');
            content.className = 'date-section-content';
            
            // Add preferred appointments
            if (preferredApts.length > 0) {
                const preferredGroup = document.createElement('div');
                preferredGroup.className = 'preferred-group';
                preferredGroup.innerHTML = '<div class="group-header">🟢 Preferred Times (closest first)</div>';
                
                const preferredGrid = document.createElement('div');
                preferredGrid.className = 'appointments-grid';
                preferredApts.forEach(apt => {
                    preferredGrid.appendChild(createAppointmentCard(apt, true));
                });
                preferredGroup.appendChild(preferredGrid);
                content.appendChild(preferredGroup);
            }
            
            // Add other appointments (collapsed by default)
            if (otherApts.length > 0) {
                const otherGroup = document.createElement('div');
                otherGroup.className = 'other-group';
                otherGroup.innerHTML = `<div class="group-header collapsible" onclick="toggleSection(this)">🔵 Other Times (${otherApts.length}) <span class="toggle">▼</span></div>`;
                
                const otherGrid = document.createElement('div');
                otherGrid.className = 'appointments-grid collapsed';
                otherApts.forEach(apt => {
                    otherGrid.appendChild(createAppointmentCard(apt, false));
                });
                otherGroup.appendChild(otherGrid);
                content.appendChild(otherGroup);
            }
            
            section.appendChild(header);
            section.appendChild(content);
            return section;
        }
        
        // Toggle collapsible sections
        function toggleSection(header) {
            const grid = header.nextElementSibling;
            const toggle = header.querySelector('.toggle');
            
            grid.classList.toggle('collapsed');
            toggle.textContent = grid.classList.contains('collapsed') ? '▼' : '▲';
        }

        function createAppointmentCard(appointment, isPreferred) {
            const card = document.createElement('div');
            card.className = `appointment-card ${isPreferred ? 'preferred' : ''} clickable`;
            
            // Make the entire card clickable
            card.onclick = function() {
                window.open(appointment.url, '_blank');
            };
            
            // Extract clean location name and show distance priority
            const locationName = appointment.locationName || appointment.center.split(/[0-9]/)[0];
            const priorityIndicator = appointment.distancePriority <= 5 ? 
                `<span class="distance-priority">#${appointment.distancePriority} closest</span>` : '';
            
            card.innerHTML = `
                <div class="appointment-header">
                    <div class="appointment-location">${locationName}</div>
                    ${priorityIndicator}
                </div>
                <div class="appointment-time">${appointment.time}</div>
            `;
            
            return card;
        }

        function displayNoAppointments() {
            const container = document.getElementById('appointmentsContainer');
            const nextCheckInterval = Math.floor(getCheckInterval() / 1000 / 60);
            
            container.innerHTML = `
                <div class="no-appointments">
                    <h3>No appointments currently available</h3>
                    <p>Checking again in <span class="countdown-timer" id="nextCheckCountdown">${nextCheckInterval} minutes</span></p>
                </div>
            `;
            
            // Clear calendar data and regenerate empty calendar
            calendarAppointments = [];
            generateCalendar();
            
            // Show appointment results (hides loading states and shows appropriate view)
            showAppointmentResults();
        }

        // Countdown timer functions
        function startCountdownTimer() {
            nextCheckTime = Date.now() + getCheckInterval();
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        function updateCountdown() {
            if (!nextCheckTime) return;
            
            const now = Date.now();
            const timeLeft = nextCheckTime - now;
            
            if (timeLeft <= 0) {
                nextCheckTime = Date.now() + getCheckInterval();
                document.getElementById('nextCheckCountdown').textContent = Math.floor(getCheckInterval() / 1000 / 60) + ' minutes';
                return;
            }
            
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            
            const countdownElements = document.querySelectorAll('#nextCheckCountdown, .countdown-timer');
            countdownElements.forEach(el => {
                el.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            });
        }

        // Helper function to convert time string to slider value
        function timeToSliderValue(timeStr) {
            const [time, period] = timeStr.split(' ');
            const [hours, minutes] = time.split(':').map(Number);
            let totalMinutes = hours * 60 + minutes;
            
            if (period === 'PM' && hours !== 12) totalMinutes += 12 * 60;
            if (period === 'AM' && hours === 12) totalMinutes = minutes;
            
            // Convert to slider value (9 AM = 54)
            return Math.floor((totalMinutes - 9 * 60) / 10) + 54;
        }

        // Browser Push Notifications
        async function requestNotificationPermission() {
            console.log('🔔 Requesting notification permission...');
            
            if (!('Notification' in window)) {
                console.warn('❌ Browser notifications not supported');
                return false;
            }
            
            if (Notification.permission === 'granted') {
                console.log('✅ Notification permission already granted');
                return true;
            }
            
            if (Notification.permission === 'denied') {
                console.warn('❌ Notification permission denied');
                return false;
            }
            
            const permission = await Notification.requestPermission();
            console.log('🔔 Notification permission result:', permission);
            return permission === 'granted';
        }

        function sendBrowserNotification(title, body, appointments = []) {
            if (!('Notification' in window) || Notification.permission !== 'granted') {
                console.warn('❌ Cannot send browser notification - permission not granted');
                return;
            }
            
            const notification = new Notification(title, {
                body: body,
                icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23059669"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>',
                tag: 'rmv-appointment',
                renotify: true,
                requireInteraction: true,
                actions: appointments.length > 0 ? [
                    { action: 'view', title: 'View Appointments' },
                    { action: 'book', title: 'Book Now' }
                ] : undefined
            });
            
            notification.onclick = function() {
                window.focus();
                // Scroll to appointments section
                document.getElementById('section5').scrollIntoView({ behavior: 'smooth' });
                notification.close();
            };
            
            // Auto close after 10 seconds if not interacted with
            setTimeout(() => {
                notification.close();
            }, 10000);
            
            console.log('🔔 Browser notification sent:', title);
        }

        function checkAndNotifyAppointments(appointments) {
            console.log('🔍 Checking appointments for notifications...', appointments.length);
            
            if (!appointments || appointments.length === 0) {
                console.log('📅 No appointments to notify about');
                return;
            }
            
            // Filter for preferred appointments
            const preferredAppointments = appointments.filter(apt => apt.isPreferred);
            const allAppointmentsCount = appointments.length;
            const preferredCount = preferredAppointments.length;
            
            console.log('🎯 Preferred appointments:', preferredCount, 'out of', allAppointmentsCount);
            
            // Send notification for preferred appointments
            if (preferredCount > 0) {
                const title = `🎯 ${preferredCount} Preferred RMV Appointment${preferredCount > 1 ? 's' : ''} Found!`;
                const body = preferredCount === 1 
                    ? `${preferredAppointments[0].center} - ${preferredAppointments[0].date} at ${preferredAppointments[0].time}`
                    : `Found ${preferredCount} appointments matching your time preferences`;
                
                sendBrowserNotification(title, body, preferredAppointments);
                stats.notifications++;
            } else if (allAppointmentsCount > 0) {
                // Send notification for any appointments if none preferred
                const title = `📅 ${allAppointmentsCount} RMV Appointment${allAppointmentsCount > 1 ? 's' : ''} Available`;
                const body = allAppointmentsCount === 1
                    ? `${appointments[0].center} - ${appointments[0].date} at ${appointments[0].time}`
                    : `Found ${allAppointmentsCount} appointments (none match your preferred times)`;
                
                sendBrowserNotification(title, body, appointments);
                stats.notifications++;
            }
            
            updateStats();
        }

        // Update statistics display
        function updateStats() {
            document.getElementById('checksCount').textContent = stats.checks;
            document.getElementById('availableCount').textContent = stats.available;
            document.getElementById('notificationsSent').textContent = stats.notifications;
            document.getElementById('matchingCount').textContent = stats.matching;
        }

        // Clear old monitoring sessions (on page load/refresh)
        async function clearOldSessions() {
            try {
                const response = await fetch('/api/clear-sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('✅ Cleared old sessions on page load:', result.message);
                        addLog('Old monitoring sessions cleared on page refresh', 'info');
                    }
                }
            } catch (error) {
                console.log('Note: Could not clear old sessions (server may not support this yet)');
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded');
            
            // Clear any old monitoring sessions on page load/refresh
            clearOldSessions();
            
            initializeUI();
            
            // Additional fallback for connect button
            setTimeout(() => {
                const connectBtn = document.getElementById('connectRMV');
                const zipField = document.getElementById('zipCode');
                console.log('Fallback check - Connect button:', connectBtn);
                console.log('Fallback check - ZIP field:', zipField);
                
                if (connectBtn && !connectBtn.hasAttribute('data-listener-added')) {
                    console.log('Adding fallback connect event listener');
                    connectBtn.onclick = connectToRMV;
                    connectBtn.setAttribute('data-listener-added', 'true');
                }
                
                if (zipField) {
                    console.log('Adding fallback ZIP event listener');
                    zipField.oninput = handleZipCodeInput;
                }
            }, 100);
        });

        // Handle page visibility change to adjust monitoring frequency
        document.addEventListener('visibilitychange', () => {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                if (!document.hidden) {
                    monitoringInterval = setInterval(checkAppointments, getCheckInterval());
                    addLog('Monitoring resumed', 'info');
                }
            }
        });

        // View Toggle Functions
        function switchToListView() {
            document.getElementById('listViewContent').style.display = 'block';
            document.getElementById('calendarViewContent').style.display = 'none';
            document.getElementById('listViewBtn').classList.add('active');
            document.getElementById('calendarViewBtn').classList.remove('active');
            console.log('📋 Switched to List View');
        }

        function switchToCalendarView() {
            document.getElementById('listViewContent').style.display = 'none';
            document.getElementById('calendarViewContent').style.display = 'block';
            document.getElementById('listViewBtn').classList.remove('active');
            document.getElementById('calendarViewBtn').classList.add('active');
            console.log('📅 Switched to Calendar View');
        }

        // Calendar View Global Variables
        let currentCalendarMonth = new Date();
        let calendarAppointments = [];
        
        // Calendar navigation functions
        function previousMonth() {
            currentCalendarMonth.setMonth(currentCalendarMonth.getMonth() - 1);
            generateCalendar();
            console.log('📅 Calendar: Navigated to previous month:', currentCalendarMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }));
        }
        
        function nextMonth() {
            currentCalendarMonth.setMonth(currentCalendarMonth.getMonth() + 1);
            generateCalendar();
            console.log('📅 Calendar: Navigated to next month:', currentCalendarMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }));
        }

        // Calendar View Functions
        function showCalendarView() {
            console.log('📅 Calendar: Showing calendar view');
            
            // Set calendar to start from user's start date
            const startDateInput = document.getElementById('startDate');
            console.log('🔍 DEBUG: Start date input found:', startDateInput ? 'YES' : 'NO');
            console.log('🔍 DEBUG: Start date value:', startDateInput ? startDateInput.value : 'N/A');
            
            if (startDateInput && startDateInput.value) {
                console.log('🔍 DEBUG: About to parse date:', startDateInput.value);
                
                // Parse date in local timezone to avoid UTC conversion issues
                const dateParts = startDateInput.value.split('-');
                const year = parseInt(dateParts[0]);
                const month = parseInt(dateParts[1]) - 1; // Month is 0-based
                const day = parseInt(dateParts[2]);
                const startDate = new Date(year, month, day);
                
                console.log('🔍 DEBUG: Parsed start date object (local timezone):', startDate);
                console.log('🔍 DEBUG: Parsed month (0-based):', startDate.getMonth());
                console.log('🔍 DEBUG: Parsed year:', startDate.getFullYear());
                console.log('🔍 DEBUG: Start date valid:', !isNaN(startDate.getTime()));
                
                if (!isNaN(startDate.getTime())) {
                    currentCalendarMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
                    console.log('🔍 DEBUG: Set currentCalendarMonth to:', currentCalendarMonth);
                    console.log('🔍 DEBUG: Final calendar month (1-based):', currentCalendarMonth.getMonth() + 1);
                    console.log('🔍 DEBUG: Final calendar year:', currentCalendarMonth.getFullYear());
                }
            } else if (calendarAppointments.length > 0) {
                // Fallback: use the month of the first appointment
                const firstAppointment = calendarAppointments[0];
                const appointmentDate = new Date(firstAppointment.date);
                console.log('📅 Calendar: Fallback to first appointment date:', firstAppointment.date, appointmentDate);
                
                if (!isNaN(appointmentDate.getTime())) {
                    currentCalendarMonth = new Date(appointmentDate.getFullYear(), appointmentDate.getMonth(), 1);
                    console.log('📅 Calendar: Set month to first appointment:', currentCalendarMonth);
                }
            } else {
                console.log('📅 Calendar: No start date or appointments found, using current month:', currentCalendarMonth);
            }
            
            console.log('📅 Calendar: Total appointments to display:', calendarAppointments.length);
            
            document.getElementById('calendarInactive').style.display = 'none';
            document.getElementById('calendarView').style.display = 'block';
            generateCalendar();
        }

        function hideCalendarView() {
            document.getElementById('calendarInactive').style.display = 'block';
            document.getElementById('calendarView').style.display = 'none';
        }

        function updateCalendarData(appointments) {
            console.log('📅 Calendar: Updating with appointments:', appointments);
            calendarAppointments = appointments || [];
            console.log('📅 Calendar: Stored appointments count:', calendarAppointments.length);
            if (calendarAppointments.length > 0) {
                console.log('📅 Calendar: Sample appointment:', calendarAppointments[0]);
            }
            if (document.getElementById('calendarView').style.display !== 'none') {
                generateCalendar();
            }
        }

        function isAppointmentInPreferredWindow(appointment) {
            // Use appointment's built-in isPreferred flag if available (from regular appointment processing)
            if (appointment.hasOwnProperty('isPreferred')) {
                console.log(`📅 Calendar: Using existing isPreferred flag for ${appointment.date} ${appointment.time}:`, appointment.isPreferred);
                return appointment.isPreferred;
            }
            
            // Get user preferences with null checks
            const startDateEl = document.getElementById('startDate');
            const endDateEl = document.getElementById('endDate');
            const startTimeEl = document.getElementById('startTime');
            const endTimeEl = document.getElementById('endTime');
            
            if (!startDateEl || !endDateEl || !startTimeEl || !endTimeEl || 
                !startDateEl.value || !endDateEl.value || !startTimeEl.value || !endTimeEl.value) {
                console.log('📅 Calendar: Form elements not found or empty, defaulting to false');
                return false;
            }
            
            const startDate = new Date(startDateEl.value);
            const endDate = new Date(endDateEl.value);
            const startTimeSlider = parseInt(startTimeEl.value);
            const endTimeSlider = parseInt(endTimeEl.value);
            
            console.log('📅 Calendar: User preferences:', {
                startDate: startDate.toDateString(),
                endDate: endDate.toDateString(),
                startTimeSlider,
                endTimeSlider
            });
            
            // Parse appointment date and time
            const aptDate = new Date(appointment.date);
            const aptTime = timeToSliderValue(appointment.time);
            
            // Check if appointment matches preferences
            const matchesTimePrefs = aptTime >= startTimeSlider && aptTime <= endTimeSlider;
            const matchesDatePrefs = aptDate >= startDate && aptDate <= endDate;
            
            console.log(`📅 Calendar: Checking ${appointment.date} ${appointment.time}:`, {
                aptTime,
                matchesTimePrefs,
                matchesDatePrefs,
                result: matchesTimePrefs && matchesDatePrefs
            });
            
            return matchesTimePrefs && matchesDatePrefs;
        }

        function generateCalendar() {
            const year = currentCalendarMonth.getFullYear();
            const month = currentCalendarMonth.getMonth();
            
            // Update header
            document.getElementById('currentMonthYear').textContent = 
                new Date(year, month).toLocaleDateString('en-US', { 
                    month: 'long', 
                    year: 'numeric' 
                });

            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();

            // Get previous month days needed
            const prevMonth = new Date(year, month - 1, 0);
            const daysInPrevMonth = prevMonth.getDate();

            let calendarHTML = '';
            
            // Day headers
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayHeaders.forEach(day => {
                calendarHTML += `<div class="calendar-day-header">${day}</div>`;
            });

            // Previous month trailing days
            for (let i = startingDayOfWeek - 1; i >= 0; i--) {
                const day = daysInPrevMonth - i;
                calendarHTML += `<div class="calendar-day other-month">
                    <span class="calendar-day-number">${day}</span>
                </div>`;
            }

            // Current month days
            for (let day = 1; day <= daysInMonth; day++) {
                const currentDate = new Date(year, month, day);
                const dateString = formatDateForComparison(currentDate);
                
                const dayAppointments = getDayAppointments(dateString);
                const appointmentInfo = categorizeAppointments(dayAppointments);
                
                let dayClasses = 'calendar-day';
                let appointmentIndicators = '';
                
                if (dayAppointments.length > 0) {
                    dayClasses += ' has-appointments';
                    
                    if (appointmentInfo.hasPreferred) {
                        dayClasses += ' preferred-appointments';
                    }
                    
                    // Add appointment indicators
                    appointmentIndicators = `
                        <div class="appointment-indicators">
                            ${appointmentInfo.preferredCount > 0 ? 
                                Array(Math.min(appointmentInfo.preferredCount, 3)).fill(0).map(() => 
                                    '<div class="appointment-dot"></div>').join('') : ''}
                            ${appointmentInfo.outsideCount > 0 ? 
                                Array(Math.min(appointmentInfo.outsideCount, 3)).fill(0).map(() => 
                                    '<div class="appointment-dot outside-window"></div>').join('') : ''}
                        </div>
                        <div class="appointment-count">${dayAppointments.length}</div>
                    `;
                }
                
                calendarHTML += `
                    <div class="${dayClasses}" onclick="showDayModal('${dateString}', ${day})">
                        <span class="calendar-day-number">${day}</span>
                        ${appointmentIndicators}
                    </div>
                `;
            }

            // Next month leading days
            const totalCells = Math.ceil((startingDayOfWeek + daysInMonth) / 7) * 7;
            const remainingCells = totalCells - (startingDayOfWeek + daysInMonth);
            
            for (let day = 1; day <= remainingCells; day++) {
                calendarHTML += `<div class="calendar-day other-month">
                    <span class="calendar-day-number">${day}</span>
                </div>`;
            }

            document.getElementById('calendarGrid').innerHTML = calendarHTML;
        }

        function getDayAppointments(dateString) {
            console.log(`📅 Calendar: Getting appointments for ${dateString}`);
            console.log(`📅 Calendar: Total appointments available:`, calendarAppointments.length);
            
            const dayAppointments = calendarAppointments.filter(appointment => {
                const appointmentDate = formatDateForComparison(new Date(appointment.date));
                const matches = appointmentDate === dateString;
                
                if (matches) {
                    console.log(`📅 Calendar: Found appointment for ${dateString}:`, appointment);
                }
                
                return matches;
            });
            
            console.log(`📅 Calendar: Found ${dayAppointments.length} appointments for ${dateString}`);
            return dayAppointments;
        }

        function categorizeAppointments(appointments) {
            let hasPreferred = false;
            let hasOutside = false;
            let preferredCount = 0;
            let outsideCount = 0;

            appointments.forEach(appointment => {
                if (isAppointmentInPreferredWindow(appointment)) {
                    hasPreferred = true;
                    preferredCount++;
                } else {
                    hasOutside = true;
                    outsideCount++;
                }
            });

            return { hasPreferred, hasOutside, preferredCount, outsideCount };
        }

        function formatDateForComparison(date) {
            return `${date.getMonth() + 1}/${date.getDate()}/${date.getFullYear()}`;
        }

        function navigateMonth(direction) {
            currentCalendarMonth.setMonth(currentCalendarMonth.getMonth() + direction);
            generateCalendar();
        }

        function showDayModal(dateString, dayNumber) {
            const dayAppointments = getDayAppointments(dateString);
            
            if (dayAppointments.length === 0) {
                return; // Don't show modal for days with no appointments
            }

            const modalDate = new Date(dateString);
            const modalHTML = `
                <div id="dayModal" class="modal-overlay" onclick="closeDayModal(event)">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <div class="modal-header">
                            <h3>Appointments for ${modalDate.toLocaleDateString('en-US', { 
                                weekday: 'long',
                                month: 'long', 
                                day: 'numeric',
                                year: 'numeric' 
                            })}</h3>
                            <button class="modal-close" onclick="closeDayModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            ${generateModalAppointmentsList(dayAppointments)}
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHTML);
            document.body.style.overflow = 'hidden';
        }

        function parseLocationString(location) {
            // Parse location string to separate name and address
            // Expected formats: "Danvers123 Main Street, Danvers, MA" or "Lawrence25 Main Street, Lawrence, MA"
            
            // First try to split by first number to separate name from address
            const match = location.match(/^([A-Za-z\s]+?)(\d.*)/);
            
            if (match) {
                const name = match[1].trim();
                const address = match[2].trim();
                return { name, address };
            }
            
            // Fallback: if no number found, look for common separators
            if (location.includes(' - ')) {
                const parts = location.split(' - ');
                return { name: parts[0].trim(), address: parts[1].trim() };
            }
            
            // Final fallback: use the whole string as name
            return { name: location, address: '' };
        }

        function generateModalAppointmentsList(appointments) {
            if (appointments.length === 0) {
                return '<p>No appointments available for this day.</p>';
            }

            // Group by location
            const appointmentsByLocation = {};
            appointments.forEach(appointment => {
                const location = appointment.center || appointment.officeName || 'Unknown Location';
                if (!appointmentsByLocation[location]) {
                    appointmentsByLocation[location] = [];
                }
                appointmentsByLocation[location].push(appointment);
            });

            let html = '';
            Object.entries(appointmentsByLocation).forEach(([location, locationAppointments]) => {
                // Parse location to separate name and address
                const locationParts = parseLocationString(location);
                
                html += `
                    <div class="modal-location-group">
                        <h4 class="modal-location-title">${locationParts.name}</h4>
                        <div class="modal-location-address">${locationParts.address}</div>
                        <div class="modal-appointments-grid">
                `;

                locationAppointments.forEach(appointment => {
                    const isPreferred = isAppointmentInPreferredWindow(appointment);
                    const timeClass = isPreferred ? 'preferred' : '';
                    const timeLabel = isPreferred ? 'In preferred window' : '';

                    html += `
                        <div class="modal-appointment-card ${timeClass}">
                            <div class="modal-appointment-time">
                                ${appointment.time}
                            </div>
                            ${timeLabel ? `<div class="modal-appointment-label">
                                ${timeLabel}
                            </div>` : ''}
                            <a href="${appointment.url}" target="_blank" class="modal-appointment-book">
                                Book Appointment
                            </a>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            return html;
        }

        function closeDayModal(event) {
            if (event && event.target !== event.currentTarget && !event.target.classList.contains('modal-close')) {
                return;
            }
            
            const modal = document.getElementById('dayModal');
            if (modal) {
                modal.remove();
                document.body.style.overflow = '';
            }
        }

        // Update the displayAppointments function to also update calendar
        const originalDisplayAppointments = window.displayAppointments;
        if (originalDisplayAppointments) {
            window.displayAppointments = function(appointments) {
                // Call original function (this now handles calendar update with processed appointments)
                originalDisplayAppointments(appointments);
            };
        }

        // View switching functions
        function switchToListView() {
            // Toggle view visibility
            document.getElementById('calendarViewContent').style.display = 'none';
            document.getElementById('listViewContent').style.display = 'block';
            
            // Toggle button states
            document.getElementById('calendarViewBtn').classList.remove('active');
            document.getElementById('listViewBtn').classList.add('active');
            
            // Update loading states if monitoring is active
            updateLoadingStatesForCurrentView();
        }

        function switchToCalendarView() {
            // Toggle view visibility
            document.getElementById('listViewContent').style.display = 'none';
            document.getElementById('calendarViewContent').style.display = 'block';
            
            // Toggle button states
            document.getElementById('listViewBtn').classList.remove('active');
            document.getElementById('calendarViewBtn').classList.add('active');
            
            // Update loading states if monitoring is active
            updateLoadingStatesForCurrentView();
        }

        function updateLoadingStatesForCurrentView() {
            // Check if monitoring is currently active by looking for loading states
            const listLoading = document.getElementById('appointmentsLoading');
            const calendarLoading = document.getElementById('calendarLoading');
            
            const isMonitoringActive = (listLoading && listLoading.style.display === 'block') || 
                                     (calendarLoading && calendarLoading.style.display === 'block');
            
            if (isMonitoringActive) {
                // If monitoring is active, show loading states for both views
                showLoadingStates();
            }
        }
        
        // Dynamic Location Discovery Functions
        async function discoverLocationsFromUrl() {
            const rmvUrl = document.getElementById('rmvUrl').value;
            
            if (!rmvUrl || !rmvUrl.includes('rmvmassdotappt.cxmflow.com')) {
                // If URL is cleared or invalid, revert to default locations
                if (isUsingDynamicLocations) {
                    addLog('Reverted to default locations', 'info');
                    serviceCenters = [...originalServiceCenters];
                    populateServiceCenters();
                    isUsingDynamicLocations = false;
                    
                    // Reset regional mappings to default
                    updateRegionalMappings();
                    
                    // Re-enable distance sorting if ZIP was entered
                    if (userZipCoords) {
                        document.getElementById('sortDistance').disabled = false;
                    }
                }
                return;
            }
            
            addLog('🔍 Discovering available locations from RMV URL...', 'info');
            
            try {
                const response = await fetch('/api/discover-locations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ rmvUrl })
                });
                
                const data = await response.json();
                
                if (data.success && data.totalFound > 0) {
                    // Convert discovered locations to the format expected by this advanced UI
                    const locationObjects = data.locations.length > 0 ? data.locations : data.offices;
                    
                    const discoveredServiceCenters = locationObjects.map(loc => {
                        // Try to find matching coordinates from originalServiceCenters
                        const existingCenter = originalServiceCenters.find(center => 
                            center.name.toLowerCase() === (loc.name || loc.displayName).toLowerCase()
                        );
                        
                        return {
                            name: loc.name || loc.displayName,
                            address: loc.address || existingCenter?.address || 'Address not available',
                            lat: parseFloat(loc.latitude) || existingCenter?.lat || 42.3601, // Default to Boston coords
                            lng: parseFloat(loc.longitude) || existingCenter?.lng || -71.0589
                        };
                    });
                    
                    // Update the serviceCenters array
                    discoveredLocations = data;
                    serviceCenters = discoveredServiceCenters;
                    isUsingDynamicLocations = true;
                    
                    // Clear selections and repopulate
                    selectedCenters.clear();
                    populateServiceCenters();
                    
                    // Update regional mappings for new locations
                    updateRegionalMappings();
                    
                    // Update distance calculations if ZIP was entered
                    if (userZipCoords) {
                        centersWithDistance = serviceCenters.map(center => ({
                            ...center,
                            distance: calculateDistance(userZipCoords.lat, userZipCoords.lng, center.lat, center.lng)
                        })).sort((a, b) => a.distance - b.distance);
                        
                        // If currently in distance mode, update the display
                        if (sortMode === 'distance') {
                            populateServiceCenters(centersWithDistance);
                        }
                    }
                    
                    addLog(`✅ Found ${data.totalFound} locations from your RMV URL in ${data.duration}s`, 'success');
                    addLog('📋 Location list updated with actual RMV locations', 'info');
                    
                } else if (data.success && data.totalFound === 0) {
                    addLog('⚠️ No locations found in RMV URL. Using default locations.', 'warning');
                    serviceCenters = [...originalServiceCenters];
                    populateServiceCenters();
                    isUsingDynamicLocations = false;
                } else {
                    addLog('❌ Failed to discover locations: ' + (data.error || 'Unknown error'), 'error');
                    serviceCenters = [...originalServiceCenters];
                    populateServiceCenters();
                    isUsingDynamicLocations = false;
                }
                
            } catch (error) {
                addLog('❌ Error discovering locations: ' + error.message, 'error');
                serviceCenters = [...originalServiceCenters];
                populateServiceCenters();
                isUsingDynamicLocations = false;
            }
        }
        
    </script>

    <!-- Modal Styles -->
    <style>
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
        }

        .modal-header h3 {
            margin: 0;
            color: #374151;
            font-size: 1.25rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 4px;
            line-height: 1;
            border-radius: 4px;
        }

        .modal-close:hover {
            background: #e5e7eb;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            max-height: calc(80vh - 120px);
        }

        .modal-location-group {
            margin-bottom: 30px;
        }

        .modal-location-group:last-child {
            margin-bottom: 0;
        }

        .modal-location-title {
            color: #374151;
            margin: 0 0 8px 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-location-address {
            color: #6b7280;
            font-size: 0.9rem;
            margin: 0 0 16px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
            line-height: 1.4;
        }

        .modal-appointments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
        }

        .modal-appointment-card {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .modal-appointment-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .modal-appointment-card.preferred {
            background: #dcfce7;
            border-color: #22c55e;
        }


        .modal-appointment-time {
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
            margin-bottom: 8px;
        }

        .modal-appointment-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 12px;
        }

        .modal-appointment-book {
            display: inline-block;
            background: #3b82f6;
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            transition: background 0.2s ease;
        }

        .modal-appointment-book:hover {
            background: #2563eb;
            color: white;
            text-decoration: none;
        }

        @media (max-width: 768px) {
            .modal-content {
                margin: 10px;
                max-height: 90vh;
            }

            .modal-appointments-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</body>
</html>