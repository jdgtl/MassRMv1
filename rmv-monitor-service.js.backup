// Complete RMV Monitor Service with User Data Extraction
const express = require('express');
const cors = require('cors');
const path = require('path');
const winston = require('winston');
const fs = require('fs').promises;

// User data extraction modules
const { RMVUserDataExtractor, EnhancedRMVScraper } = require('./rmv-user-data-extractor');

// Configuration
const config = {
    port: process.env.PORT || 3000,
    checkInterval: process.env.CHECK_INTERVAL || 5,
    expireDate: new Date('2025-09-03T23:59:59')
};

// Logger setup
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.simple()
    ),
    transports: [
        new winston.transports.Console()
    ]
});

// Simple database simulation
const db = {
    async load() {
        try {
            const data = await fs.readFile('./data.json', 'utf8');
            return JSON.parse(data);
        } catch (error) {
            return { appointments: [], users: [], extractedUserData: {} };
        }
    },
    async save(data) {
        await fs.writeFile('./data.json', JSON.stringify(data, null, 2));
    },
    async logAppointment(appointment) {
        const data = await this.load();
        data.appointments.push({
            ...appointment,
            id: Date.now(),
            timestamp: new Date().toISOString()
        });
        await this.save(data);
    }
};

// Import puppeteer for real browser functionality (with fallback)
let puppeteer;
try {
    puppeteer = require('puppeteer');
} catch (error) {
    logger.warn('Puppeteer not available, using mock browser');
    puppeteer = null;
}

// RMV scraper service
const service = {
    scraper: {
        browser: null,
        async initialize() {
            if (puppeteer) {
                try {
                    this.browser = await puppeteer.launch({
                        headless: true,
                        args: ['--no-sandbox', '--disable-setuid-sandbox']
                    });
                    logger.info('Real Puppeteer browser initialized');
                    return true;
                } catch (error) {
                    logger.error('Failed to initialize Puppeteer browser:', error.message);
                    // Fallback to mock
                    this.browser = null;
                }
            }
            
            // Mock browser with newPage method for compatibility
            this.browser = {
                async newPage() {
                    return {
                        async goto() { return true; },
                        async close() { return true; },
                        url() { return 'http://mock.url'; },
                        async evaluate() { return {}; },
                        async cookies() { return []; },
                        async waitForTimeout() { return true; }
                    };
                },
                async close() { return true; }
            };
            logger.info('Mock browser initialized with compatibility layer');
            return true;
        },
        async checkRMVUrl(fullUrl, userPreferences) {
            // Production 3-Step Navigation RMV scraping
            logger.info('Starting 3-Step Navigation RMV scraping for URL:', fullUrl);
            
            if (!this.browser) {
                throw new Error('Browser not initialized');
            }

            const page = await this.browser.newPage();
            const appointments = [];
            
            // Set user agent to avoid detection
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
            
            try {
                // STEP 1: Navigate to initial URL and extract office list
                logger.info('STEP 1: Navigating to RMV booking page and loading office list...');
                await page.goto(fullUrl, { waitUntil: 'networkidle0', timeout: 30000 });
                await page.waitForTimeout(3000);
                
                // Extract location data and offices
                const rmvData = await page.evaluate(() => {
                    const data = {
                        offices: [],
                        locationData: [],
                        pageTitle: document.title,
                        debugInfo: {
                            bodyText: document.body.innerText.substring(0, 1000)
                        }
                    };
                    
                    // Extract structured location data from window.displayData
                    if (window.displayData && Array.isArray(window.displayData)) {
                        data.locationData = window.displayData.map(location => ({
                            id: location.Id,
                            name: location.Name,
                            address: location.Address
                        }));
                    }
                    
                    // Extract office buttons from the page
                    const qflowButtons = document.querySelectorAll('.QflowObjectItem[data-id]');
                    qflowButtons.forEach(btn => {
                        const officeName = btn.textContent.split('\n')[0].trim();
                        const dataId = btn.getAttribute('data-id');
                        
                        if (officeName && dataId) {
                            data.offices.push({
                                name: officeName,
                                dataId: dataId,
                                fullText: btn.textContent.trim()
                            });
                        }
                    });
                    
                    return data;
                });
                
                logger.info(`Found ${rmvData.offices.length} offices available`);
                
                // STEP 2: Filter and navigate through selected locations
                const selectedCenters = userPreferences?.centers || [];
                const matchedOffices = rmvData.offices.filter(office => 
                    selectedCenters.some(selected => 
                        office.name.toLowerCase().includes(selected.toLowerCase()) ||
                        selected.toLowerCase().includes(office.name.toLowerCase())
                    )
                );
                
                logger.info(`STEP 2: Found ${matchedOffices.length} matching offices: ${matchedOffices.map(o => o.name).join(', ')}`);
                
                // Navigate to each matched office to get appointment times
                for (const office of matchedOffices) {
                    logger.info(`STEP 3: Navigating to ${office.name} for appointment times...`);
                    
                    try {
                        // Click on the office location
                        const locationSelector = `.QflowObjectItem[data-id="${office.dataId}"]`;
                        await page.waitForSelector(locationSelector, { timeout: 5000 });
                        
                        // Human-like click behavior
                        await page.evaluate((selector) => {
                            const element = document.querySelector(selector);
                            if (element) {
                                element.click();
                            }
                        }, locationSelector);
                        
                        // Wait for navigation or form submission
                        await Promise.race([
                            page.waitForNavigation({ waitUntil: 'networkidle0', timeout: 15000 }),
                            page.waitForSelector('.ServiceAppointmentDateTime', { timeout: 10000 }),
                            new Promise(resolve => setTimeout(resolve, 8000))
                        ]);
                        
                        // Check if we're now on the appointment selection page
                        const appointmentPageTitle = await page.title();
                        logger.info(`Navigated to: ${appointmentPageTitle}`);
                        
                        // Extract appointment times using the pattern from attleboro-landing-page.html
                        const officeAppointments = await page.evaluate(() => {
                            const slots = [];
                            
                            // Look for ServiceAppointmentDateTime elements with data-datetime
                            const appointmentElements = document.querySelectorAll('.ServiceAppointmentDateTime[data-datetime]');
                            
                            appointmentElements.forEach(el => {
                                const dateTime = el.getAttribute('data-datetime');
                                const displayTime = el.textContent.trim();
                                const isAvailable = !el.classList.contains('disabled') && 
                                                  !el.classList.contains('unavailable') &&
                                                  el.classList.contains('valid');
                                
                                if (dateTime && displayTime && isAvailable) {
                                    // Parse the datetime
                                    const dt = new Date(dateTime);
                                    const date = dt.toLocaleDateString();
                                    const time = displayTime;
                                    
                                    slots.push({
                                        date: date,
                                        time: time,
                                        datetime: dateTime,
                                        displayText: displayTime,
                                        available: true
                                    });
                                }
                            });
                            
                            // Also look for grouped appointment displays
                            const groupedElements = document.querySelectorAll('.DateTimeGrouping-Container .ServiceAppointmentDateTime');
                            groupedElements.forEach(el => {
                                const dateTime = el.getAttribute('data-datetime');
                                const displayTime = el.textContent.trim();
                                const isAvailable = !el.classList.contains('disabled') && 
                                                  el.classList.contains('valid');
                                
                                if (dateTime && displayTime && isAvailable) {
                                    const dt = new Date(dateTime);
                                    const date = dt.toLocaleDateString();
                                    
                                    // Avoid duplicates
                                    const isDuplicate = slots.some(slot => 
                                        slot.datetime === dateTime
                                    );
                                    
                                    if (!isDuplicate) {
                                        slots.push({
                                            date: date,
                                            time: displayTime,
                                            datetime: dateTime,
                                            displayText: displayTime,
                                            available: true
                                        });
                                    }
                                }
                            });
                            
                            return {
                                slots: slots,
                                pageTitle: document.title,
                                totalFound: slots.length
                            };
                        });
                        
                        logger.info(`Found ${officeAppointments.totalFound} appointment slots for ${office.name}`);
                        
                        // Add appointments to our collection
                        officeAppointments.slots.forEach(slot => {
                            appointments.push({
                                center: office.name,
                                date: slot.date,
                                time: slot.time,
                                url: page.url(),
                                raw: slot.displayText,
                                type: '3-step-navigation',
                                datetime: slot.datetime,
                                officeName: office.name,
                                officeId: office.dataId
                            });
                        });
                        
                        // Go back to office selection for next office
                        if (matchedOffices.length > 1) {
                            await page.goBack();
                            await page.waitForTimeout(2000);
                        }
                        
                    } catch (officeError) {
                        logger.error(`Error processing office ${office.name}: ${officeError.message}`);
                        
                        // Try to recover by going back to the main URL
                        try {
                            await page.goto(fullUrl, { waitUntil: 'networkidle0', timeout: 15000 });
                            await page.waitForTimeout(2000);
                        } catch (recoverError) {
                            logger.error(`Recovery failed: ${recoverError.message}`);
                        }
                    }
                }
                
                // If no appointments found through navigation, check if we're already on appointment page
                if (appointments.length === 0) {
                    logger.info('No appointments found through navigation, checking if already on appointment page...');
                    
                    const currentPageAppointments = await page.evaluate(() => {
                        const slots = [];
                        const appointmentElements = document.querySelectorAll('.ServiceAppointmentDateTime[data-datetime]');
                        
                        appointmentElements.forEach(el => {
                            const dateTime = el.getAttribute('data-datetime');
                            const displayTime = el.textContent.trim();
                            const isAvailable = !el.classList.contains('disabled') && 
                                              el.classList.contains('valid');
                            
                            if (dateTime && displayTime && isAvailable) {
                                const dt = new Date(dateTime);
                                slots.push({
                                    date: dt.toLocaleDateString(),
                                    time: displayTime,
                                    datetime: dateTime,
                                    displayText: displayTime,
                                    available: true
                                });
                            }
                        });
                        
                        return slots;
                    });
                    
                    if (currentPageAppointments.length > 0) {
                        logger.info(`Found ${currentPageAppointments.length} appointments on current page`);
                        currentPageAppointments.forEach(slot => {
                            appointments.push({
                                center: selectedCenters[0] || 'RMV Location',
                                date: slot.date,
                                time: slot.time,
                                url: page.url(),
                                raw: slot.displayText,
                                type: 'direct-appointment-page',
                                datetime: slot.datetime
                            });
                        });
                    }
                }
                
            } catch (error) {
                logger.error('Error during 3-step RMV scraping:', error.message);
                throw new Error(`3-step RMV scraping failed: ${error.message}`);
            } finally {
                await page.close();
            }
            
            logger.info(`3-Step RMV scraping completed. Found ${appointments.length} total appointments across all locations`);
            return appointments;
        }
    }
};

// Express API Server
const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static('public'));
app.use(express.static(__dirname));

// Serve the main interface
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index-improved.html'));
});

// Health check endpoint
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        running: true,
        features: 'user_data_extraction_enabled',
        timestamp: new Date().toISOString(),
        message: 'RMV Monitor Service with User Data Extraction is running!'
    });
});

// Update the /api/check-appointments endpoint to include user extraction
app.post('/api/check-appointments', async (req, res) => {
    try {
        const { rmvUrl, selectedCenters, userPreferences, extractUserData } = req.body;

        // Validate input
        if (!rmvUrl) {
            return res.status(400).json({
                success: false,
                error: 'RMV URL is required',
                timestamp: new Date().toISOString()
            });
        }

        logger.info(`Starting RMV appointment check for ${selectedCenters?.length || 0} centers`);
        logger.info(`RMV URL: ${rmvUrl}`);
        logger.info(`Extract user data: ${extractUserData || false}`);

        // Initialize scraper if not already initialized
        if (!service.scraper.browser) {
            logger.info('Initializing Puppeteer browser...');
            await service.scraper.initialize();
        }

        // Create enhanced scraper for user data extraction
        const enhancedScraper = new EnhancedRMVScraper(service.scraper, logger);

        let appointments = [];
        let userData = null;

        try {
            if (extractUserData) {
                // Use enhanced scraper that also extracts user data
                const result = await enhancedScraper.checkRMVUrlWithUserData(
                    rmvUrl,
                    userPreferences || { centers: selectedCenters }
                );

                appointments = result.appointments || [];
                userData = result.userData;

                logger.info('User data extraction results:', {
                    found: userData?.foundUserInfo,
                    hasValidData: userData?.validated?.isValid,
                    source: userData?.extracted?.source
                });

                // If we found user data, save it for auto-fill
                if (userData?.validated?.isValid) {
                    await saveExtractedUserData(userData);
                }

            } else {
                // Regular appointment check without user data extraction
                appointments = await service.scraper.checkRMVUrl(
                    rmvUrl,
                    { ...userPreferences, centers: selectedCenters }
                );
            }

            // Log appointments to database
            if (appointments && appointments.length > 0) {
                logger.info(`Found ${appointments.length} appointments!`);

                for (const apt of appointments) {
                    await db.logAppointment({
                        ...apt,
                        source: 'api_check'
                    });
                }
            }

        } catch (scrapeError) {
            logger.error('Scraping error:', scrapeError);
            throw scrapeError;
        }

        // Return results with user data if extracted
        const response = {
            success: true,
            found: appointments.length > 0,
            appointments: appointments,
            timestamp: new Date().toISOString(),
            message: appointments.length > 0 ?
                `Found ${appointments.length} available appointment(s)` :
                'No appointments currently available'
        };

        if (userData) {
            response.userData = {
                found: userData.foundUserInfo,
                autoFillAvailable: userData.validated?.isValid,
                fields: userData.validated?.cleaned || {},
                source: userData.extracted?.source,
                accessToken: userData.urlParams?.accessToken,
                sessionId: userData.urlParams?.sessionId
            };
        }

        res.json(response);

    } catch (error) {
        logger.error('Error checking appointments:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to check appointments',
            details: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// New endpoint specifically for extracting user data from URL
app.post('/api/extract-user-data', async (req, res) => {
    try {
        const { rmvUrl } = req.body;

        if (!rmvUrl) {
            return res.status(400).json({
                success: false,
                error: 'RMV URL is required'
            });
        }

        logger.info('Extracting user data from RMV URL...');

        // Initialize browser if needed
        if (!service.scraper.browser) {
            await service.scraper.initialize();
        }

        const page = await service.scraper.browser.newPage();

        try {
            const extractor = new RMVUserDataExtractor(logger);

            // Setup response capture
            await extractor.setupResponseCapture(page);

            // Navigate to the URL
            await page.goto(rmvUrl, {
                waitUntil: 'networkidle2',
                timeout: 30000
            });

            // Extract user data
            const userData = await extractor.extractUserDataFromPage(page);

            // Validate the data
            const validated = extractor.validateUserData(userData);

            // Extract URL parameters
            const urlData = extractor.extractFromURLParams(rmvUrl);

            res.json({
                success: true,
                found: userData.found,
                autoFillAvailable: validated.isValid,
                extracted: {
                    firstName: validated.cleaned.firstName || null,
                    lastName: validated.cleaned.lastName || null,
                    email: validated.cleaned.email || null,
                    phone: validated.cleaned.phoneFormatted || null,
                    rawPhone: validated.cleaned.phone || null
                },
                source: userData.source,
                urlParams: {
                    accessToken: urlData.accessToken,
                    sessionId: urlData.sessionId
                },
                errors: validated.errors,
                timestamp: new Date().toISOString()
            });

        } finally {
            await page.close();
        }

    } catch (error) {
        logger.error('Error extracting user data:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to extract user data',
            details: error.message
        });
    }
});

// Helper function to save extracted user data
async function saveExtractedUserData(userData) {
    try {
        const data = await db.load();

        // Create or update extracted data cache
        if (!data.extractedUserData) {
            data.extractedUserData = {};
        }

        const sessionId = userData.urlParams?.sessionId;
        if (sessionId) {
            data.extractedUserData[sessionId] = {
                ...userData.validated.cleaned,
                extractedAt: new Date().toISOString(),
                accessToken: userData.urlParams.accessToken
            };

            await db.save(data);
            logger.info(`Saved extracted user data for session: ${sessionId}`);
        }
    } catch (error) {
        logger.error('Error saving extracted user data:', error);
    }
}

// Updated frontend JavaScript to use auto-fill
const frontendAutoFillScript = `
<script>
// Add this to your index-improved.html

let extractedUserData = null;

// Function to check for user data when URL is entered
async function checkForUserData() {
    const rmvUrl = document.getElementById('rmvUrl').value;

    if (!rmvUrl || !rmvUrl.includes('rmvmassdotappt.cxmflow.com')) {
        return;
    }

    // Show loading indicator
    showAutoFillLoading();

    try {
        const response = await fetch('/api/extract-user-data', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ rmvUrl })
        });

        const data = await response.json();

        if (data.success && data.autoFillAvailable) {
            extractedUserData = data.extracted;
            showAutoFillPrompt(data.extracted);
        } else if (data.found) {
            addLog('Some user data found but incomplete. Please fill in the missing fields.', 'info');
            partialAutoFill(data.extracted);
        } else {
            addLog('No user data found in URL. Please enter your information manually.', 'info');
        }
    } catch (error) {
        console.error('Error extracting user data:', error);
        addLog('Could not extract user data from URL', 'warning');
    } finally {
        hideAutoFillLoading();
    }
}

// Function to show auto-fill prompt
function showAutoFillPrompt(userData) {
    const promptHtml = \`
        <div class="autofill-prompt" id="autoFillPrompt">
            <div class="autofill-header">
                <h3>ðŸŽ‰ User Information Detected!</h3>
                <button onclick="closeAutoFillPrompt()" class="close-btn">Ã—</button>
            </div>
            <div class="autofill-content">
                <p>We found your information from the RMV URL:</p>
                <ul>
                    \${userData.firstName ? '<li>First Name: ' + userData.firstName + '</li>' : ''}
                    \${userData.lastName ? '<li>Last Name: ' + userData.lastName + '</li>' : ''}
                    \${userData.email ? '<li>Email: ' + userData.email + '</li>' : ''}
                    \${userData.phone ? '<li>Phone: ' + userData.phone + '</li>' : ''}
                </ul>
                <div class="autofill-actions">
                    <button onclick="applyAutoFill()" class="btn btn-primary">Use This Information</button>
                    <button onclick="closeAutoFillPrompt()" class="btn btn-secondary">Enter Manually</button>
                </div>
            </div>
        </div>
    \`;

    // Add to page
    const container = document.createElement('div');
    container.innerHTML = promptHtml;
    document.body.appendChild(container.firstElementChild);
}

// Function to apply auto-fill
function applyAutoFill() {
    if (extractedUserData) {
        if (extractedUserData.firstName) {
            document.getElementById('firstName').value = extractedUserData.firstName;
        }
        if (extractedUserData.lastName) {
            document.getElementById('lastName').value = extractedUserData.lastName;
        }
        if (extractedUserData.email) {
            document.getElementById('email').value = extractedUserData.email;
        }
        if (extractedUserData.rawPhone) {
            document.getElementById('phone').value = extractedUserData.rawPhone;
        }

        addLog('User information auto-filled successfully!', 'success');

        // Mark fields as validated
        document.querySelectorAll('.auto-filled').forEach(el => {
            el.classList.add('validated');
        });
    }

    closeAutoFillPrompt();
}

// Partial auto-fill for incomplete data
function partialAutoFill(userData) {
    if (userData.firstName && document.getElementById('firstName').value === '') {
        document.getElementById('firstName').value = userData.firstName;
        document.getElementById('firstName').classList.add('auto-filled');
    }
    if (userData.lastName && document.getElementById('lastName').value === '') {
        document.getElementById('lastName').value = userData.lastName;
        document.getElementById('lastName').classList.add('auto-filled');
    }
    if (userData.email && document.getElementById('email').value === '') {
        document.getElementById('email').value = userData.email;
        document.getElementById('email').classList.add('auto-filled');
    }
    if (userData.rawPhone && document.getElementById('phone').value === '') {
        document.getElementById('phone').value = userData.rawPhone;
        document.getElementById('phone').classList.add('auto-filled');
    }
}

// Close auto-fill prompt
function closeAutoFillPrompt() {
    const prompt = document.getElementById('autoFillPrompt');
    if (prompt) {
        prompt.remove();
    }
}

// Add event listener to RMV URL field
document.getElementById('rmvUrl').addEventListener('blur', checkForUserData);
document.getElementById('rmvUrl').addEventListener('paste', () => {
    setTimeout(checkForUserData, 100);
});

// Modified start monitoring to include user data extraction
async function startMonitoringWithExtraction() {
    if (!validateForm()) return;

    const formData = {
        rmvUrl: document.getElementById('rmvUrl').value,
        selectedCenters: Array.from(selectedCenters),
        userPreferences: {
            startTime: document.getElementById('startTimeSlider').value,
            endTime: document.getElementById('endTimeSlider').value,
            startDate: document.getElementById('startDate').value,
            endDate: document.getElementById('endDate').value
        },
        extractUserData: true // Enable user data extraction
    };

    // Call the API with extraction enabled
    const response = await fetch('/api/check-appointments', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(formData)
    });

    const data = await response.json();

    if (data.userData && data.userData.found) {
        addLog('User data extracted from RMV session', 'success');
    }

    // Continue with normal monitoring...
}

// CSS for auto-fill prompt
const autoFillStyles = \`
<style>
.autofill-prompt {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 15px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    padding: 25px;
    z-index: 10000;
    max-width: 500px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -60%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

.autofill-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid #f0f0f0;
}

.autofill-header h3 {
    margin: 0;
    color: #667eea;
}

.close-btn {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #999;
}

.autofill-content ul {
    list-style: none;
    padding: 0;
    margin: 15px 0;
}

.autofill-content li {
    padding: 8px 0;
    border-bottom: 1px solid #f0f0f0;
}

.autofill-actions {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.auto-filled {
    background-color: #e8f5e9 !important;
    border-color: #4caf50 !important;
}

.auto-filled.validated {
    border-color: #2e7d32 !important;
}

.autofill-loading {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
}

.autofill-loading::after {
    content: 'âš¡';
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}
</style>
\`;

// Add styles to page
document.head.insertAdjacentHTML('beforeend', autoFillStyles);
<\/script>
`;

// Start the server
async function startServer() {
    try {
        app.listen(config.port, () => {
            logger.info(`âœ… RMV Monitor Service running on http://localhost:${config.port}`);
            logger.info(`âœ… User data extraction enabled`);
            logger.info(`âœ… Service will expire on ${config.expireDate.toLocaleDateString()}`);
            logger.info(`ðŸ“± Open http://localhost:${config.port} in your browser`);
            logger.info(`ðŸ” Health check: http://localhost:${config.port}/health`);
        });
    } catch (error) {
        logger.error('Failed to start server:', error);
        process.exit(1);
    }
}

// Graceful shutdown
process.on('SIGINT', () => {
    logger.info('Received SIGINT, shutting down gracefully...');
    process.exit(0);
});

process.on('SIGTERM', () => {
    logger.info('Received SIGTERM, shutting down gracefully...');
    process.exit(0);
});

// Start the service
startServer();